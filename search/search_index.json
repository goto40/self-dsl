{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to self-dsl This is a tutorial site for the creation of domain specific languages. Motivation : Why using a DSL? What is the value of it? What is MDSD? Basics of meta modeling What is meta modeled? Tutorial-like topics for Xtext and TextX (see sidebar). References Development, Sources, License See: github sources Employed software to generate this documentation We use MkDocs to build these pages (using the Read the Docs theme). We employ PlantUML to produce UML graphics (together with a plugin working together with MkDocs ).","title":"Welcome to self-dsl"},{"location":"#welcome-to-self-dsl","text":"This is a tutorial site for the creation of domain specific languages. Motivation : Why using a DSL? What is the value of it? What is MDSD? Basics of meta modeling What is meta modeled? Tutorial-like topics for Xtext and TextX (see sidebar). References","title":"Welcome to self-dsl"},{"location":"#development-sources-license","text":"See: github sources","title":"Development, Sources, License"},{"location":"#employed-software-to-generate-this-documentation","text":"We use MkDocs to build these pages (using the Read the Docs theme). We employ PlantUML to produce UML graphics (together with a plugin working together with MkDocs ).","title":"Employed software to generate this documentation"},{"location":"basics/","text":"Basics of meta modeling for domain models In this section we describe typical meta modeling tasks. Meta modeling is the creation of a meta model. This defines what can be modeled in a model for that given meta model. All aspects identified here can be found in a tutorial style in corresponding sections for TextX and Xtext of this documentation. Introductory example An example: A meta model for a programming language defines that, e.g., variables can be defined. The model, in turn, is a concrete program with many variable definitions. A meta model may, thus, be sketched as follows: A program (domain model) may look as follows: Overview: aspects of meta modeling A summary of different aspects to be specified by the meta model is given as follows. This list is inspired by the grammar based toolset Xtext and TextX . Which domain objects exist ( glossary )? How are objects identified ( named )? Which attributes do objects have? What objects are composed of other objects? What objects aggregate other objects? How do objects reference each other (including context effects/ scoping )? How can I specialize objects? How can I connect objects? Modularization : How can an object reference another object from another model (form the same meta model or a different one)? Interoperability : How can an object reference something from outside the toolset scope (inter-tool operability)? Validation : How can custom rules be checked automatically? Domain objects: identification and attributes Domain objects represent a central part of a glossary . Thus, defining such objects is a central part of any software specification and must be using through its design. Domain objects can represent things, like \"Customers\", \"Computers\", \"State machines\". In our context they can also represent activities and relationships, like \"owns\" (a customers owns a computer) or \"runs\" (a computer runs a state machine). Domain objects may have attributes , some of them optional. These attributes may have a scalar value or represent a list of entries. The value of the attributes can be specified to represent some basic type (like a string or a number) or other domain objects. Importantly, some domain objects need to be identified by a name (like a \"Customer\"), while other objects do not (like the \"Birthday\" in our example below). Note: Domain objects in the meta model represent a blueprint or a class of a concrete instances of such objects in a concrete model. Composing objects Domain objects may be composed of other domain objects. Such a relationship can be described by an attribute with a domain object type (like in the last section). An alternative representation is illustrated as follows, but describes exactly the same thing: Note: in this example, a Customer is composed of a Birthday object. The Birthday object cannot exist without the Customer. This relationship is called composition and has clear ownership semantics. References and Aggregation Some domain objects need to reference identifiable objects without having their ownership. This happens, e.g., when describing domain object relationships within the model (e.g. a Customer owns a Computer; relationship \"own\"). Such relationships themselves can own additional attributes (e.g. \"owns since date\"). Note: non-owning knowledge of other objects is called aggregation . Simple relationships can be presented by a simple link (without attributes and without own rule/class definition). Scoping Scoping is relevant to describe what objects are identifiable when referencing other objects . This is especially of importance, when some default visibility is not valid (most default scoping mechanisms allow all identifiable objects to be referenced globally). Assume the following meta model snippet, where a \"Scenario\" is composed of \"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\": In this case, we want that only \"Configurations\" of the \"Scenario\" referenced by a \"Testcase\" are visible to the \"Testcase\" . This restriction is context specific (to the context of the \"Testcase\" described by the referenced \"Scenario\"). Scoping mechanisms allow to define this scope. Specialization (base classes/base rules) Sometimes it happens that some domain object is too generic and needs to be specialized. This may happen when the language evolves. During the initial design commonalities are identified which lead to the same pattern (base class and specialization). Modularization This happens when a model is splitted in multiple submodels (e.g., different files). Combining meta models To foster modularization, meta models can be splitted and still allow to reference domain objects of one meta model from the other meta model. In our last example we could define a meta model for \"Testcases\" and one meta model for \"Scenarios\". This feature is more demanding to the underlying technology but allows a modularization of the meta model and, thus, the glossary . Interoperability with other toolsets or software components In larger projects external databases or models may need to be referenced. Such external sources of information may be, e.g., an existing database of requirements, some JSON or XML file or similar things. Interoperability with these sources of information allow to link the model to that source. Validation The validation of a model consists of additional checks on top of structural consistency defined by the grammar and scoping. Error in the structure result in classical syntax errors (\" expected 'XY' instead of 'AB'\"). Scoping, in turn, defines the possible references in some context and, thus, yields errors of the category \"referenced element 'XY' not found .\". The validation described in this section is about additional logical checks , once the model is correctly parsed and all references resolved. This additional checks typically have a strong relation to the domain . Example: Assume a model where \"testcases\" reference \"configurations of scenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may need certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not availabe in the referenced \"configuration\", a logical error is reported (validation error). Rationale for choosing a validation over a scoping solution in this case: When modeling a situation where a \"configuration\" is chosen by a \"testcase\" without providing the correct \"aspects\", one would not like to get a \"configuration not found\", which would result if only \"configurations\" with matching \"aspects\" are defined in the scope of a \"testcase\". In contrast, the validation will allow all \"configurations\" of the selected \"scenario\" of a \"testcase\" to be visible, but some of them will produce a meaningful domain error , such as \"configuration 'config_B' does not provide the aspect 'aspect_X' required by testcase 'test_T1'\". The structure defined in the meta model is shown as follows: A model with validation error ( \"configuration 'config_B' does not provide the aspect 'aspect_X' required by testcase 'test_T1'\" ) is shown as follows: scenario scenario_001 { configuration config_A has { aspect_X } configuration config_B has { aspect_Y } } testcase test_T1 { use scenario_001 with config_B and needs { aspect_X } } A model without validation error is shown as follows: scenario scenario_001 { configuration config_A has { aspect_X } configuration config_B has { aspect_Y , aspect_X } } testcase test_T1 { use scenario_001 with config_B and needs { aspect_X } }","title":"Basics of meta modeling for domain models"},{"location":"basics/#basics-of-meta-modeling-for-domain-models","text":"In this section we describe typical meta modeling tasks. Meta modeling is the creation of a meta model. This defines what can be modeled in a model for that given meta model. All aspects identified here can be found in a tutorial style in corresponding sections for TextX and Xtext of this documentation.","title":"Basics of meta modeling for domain models"},{"location":"basics/#introductory-example","text":"An example: A meta model for a programming language defines that, e.g., variables can be defined. The model, in turn, is a concrete program with many variable definitions. A meta model may, thus, be sketched as follows: A program (domain model) may look as follows:","title":"Introductory example"},{"location":"basics/#overview-aspects-of-meta-modeling","text":"A summary of different aspects to be specified by the meta model is given as follows. This list is inspired by the grammar based toolset Xtext and TextX . Which domain objects exist ( glossary )? How are objects identified ( named )? Which attributes do objects have? What objects are composed of other objects? What objects aggregate other objects? How do objects reference each other (including context effects/ scoping )? How can I specialize objects? How can I connect objects? Modularization : How can an object reference another object from another model (form the same meta model or a different one)? Interoperability : How can an object reference something from outside the toolset scope (inter-tool operability)? Validation : How can custom rules be checked automatically?","title":"Overview: aspects of meta modeling"},{"location":"basics/#domain-objects-identification-and-attributes","text":"Domain objects represent a central part of a glossary . Thus, defining such objects is a central part of any software specification and must be using through its design. Domain objects can represent things, like \"Customers\", \"Computers\", \"State machines\". In our context they can also represent activities and relationships, like \"owns\" (a customers owns a computer) or \"runs\" (a computer runs a state machine). Domain objects may have attributes , some of them optional. These attributes may have a scalar value or represent a list of entries. The value of the attributes can be specified to represent some basic type (like a string or a number) or other domain objects. Importantly, some domain objects need to be identified by a name (like a \"Customer\"), while other objects do not (like the \"Birthday\" in our example below). Note: Domain objects in the meta model represent a blueprint or a class of a concrete instances of such objects in a concrete model.","title":"Domain objects: identification and attributes"},{"location":"basics/#composing-objects","text":"Domain objects may be composed of other domain objects. Such a relationship can be described by an attribute with a domain object type (like in the last section). An alternative representation is illustrated as follows, but describes exactly the same thing: Note: in this example, a Customer is composed of a Birthday object. The Birthday object cannot exist without the Customer. This relationship is called composition and has clear ownership semantics.","title":"Composing objects"},{"location":"basics/#references-and-aggregation","text":"Some domain objects need to reference identifiable objects without having their ownership. This happens, e.g., when describing domain object relationships within the model (e.g. a Customer owns a Computer; relationship \"own\"). Such relationships themselves can own additional attributes (e.g. \"owns since date\"). Note: non-owning knowledge of other objects is called aggregation . Simple relationships can be presented by a simple link (without attributes and without own rule/class definition).","title":"References and Aggregation"},{"location":"basics/#scoping","text":"Scoping is relevant to describe what objects are identifiable when referencing other objects . This is especially of importance, when some default visibility is not valid (most default scoping mechanisms allow all identifiable objects to be referenced globally). Assume the following meta model snippet, where a \"Scenario\" is composed of \"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\": In this case, we want that only \"Configurations\" of the \"Scenario\" referenced by a \"Testcase\" are visible to the \"Testcase\" . This restriction is context specific (to the context of the \"Testcase\" described by the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.","title":"Scoping"},{"location":"basics/#specialization-base-classesbase-rules","text":"Sometimes it happens that some domain object is too generic and needs to be specialized. This may happen when the language evolves. During the initial design commonalities are identified which lead to the same pattern (base class and specialization).","title":"Specialization (base classes/base rules)"},{"location":"basics/#modularization","text":"This happens when a model is splitted in multiple submodels (e.g., different files).","title":"Modularization"},{"location":"basics/#combining-meta-models","text":"To foster modularization, meta models can be splitted and still allow to reference domain objects of one meta model from the other meta model. In our last example we could define a meta model for \"Testcases\" and one meta model for \"Scenarios\". This feature is more demanding to the underlying technology but allows a modularization of the meta model and, thus, the glossary .","title":"Combining meta models"},{"location":"basics/#interoperability-with-other-toolsets-or-software-components","text":"In larger projects external databases or models may need to be referenced. Such external sources of information may be, e.g., an existing database of requirements, some JSON or XML file or similar things. Interoperability with these sources of information allow to link the model to that source.","title":"Interoperability with other toolsets or software components"},{"location":"motivation/","text":"Motivation The problem to be solved is two-fold: avoid problems with communication and consistency . A common language will be defined to ease communication within and between teams. A single source of information implies consistency , and in turn, prevents misunderstandings. A very good introduction to domain modeling is (Tomassetti, 2017) . MDSD and DSLs Model driven software development (MDSD) allows introducing a supplementary layer of abstraction above the code: This additional complexity can be employed to complement, and in some cases replace traditional model based design approaches, and thus represents a significant design element of a software architecture. Such model driven approaches often also refer to domain specific languages (DSL) . These languages make the design easy to communicate (defined language at design level) and at the same time the design itself constitutes of actual software artifacts, since code is directly generated from it (single source of information). Meta-model, model, and all that The meta modeling toolsets utilized on this site typically allow to define (1) a meta model , which defines what is modeled, e.g., the basic layout of a data structure in terms of structures which have attributes. This meta model can be compared to a data base layout . It also can be compared to glossary for a given domain. Using the meta model (2) model data can be defined by a user. This model data represents the concrete data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate and check concrete models. Finally, (4) code generators and model transformations represent primary end user tools to allow mass production based on a single source of information (the model). Real value for a project Notably, if a model represents a real abstraction of a software aspect - something people talk about and which hides important details - we get a big impact in productivity. From the one and single source of specification (the model data) we can extract documentation, plan and archive changes (in the models) and at the same time guarantee the consistency of model and multiple code artifacts. The real value in terms of working hours is not the meta model, the code generator or the editor of a model, but the model data itself. The rest of the employed toolset and definitions (e.g. the meta model) further increase this value, by allowing to validate, transform or evaluate the model data. Keeping this in mind, one should be able to parse and understand the model data in, say, 10 years. Also think about what happens if multiple users create conflicts in model files. One should be able to repair such situations. This is easier if the model stored on disk resembles the model entered by the user, than if an alternative representation is used with, e.g., binary data representations or machine generated IDs which are difficult to understand. Such a simple representation on disk also allows to easily analyze a model with a traditional text search tool (grep) and to make quick modifications to the model with a simple editor. Moreover, the interoperability of employed toolsets is of crucial importancy: the ability to define inter-model relations eases large scale model driven approaches and the IDE integration increases end user acceptance.","title":"Motivation"},{"location":"motivation/#motivation","text":"The problem to be solved is two-fold: avoid problems with communication and consistency . A common language will be defined to ease communication within and between teams. A single source of information implies consistency , and in turn, prevents misunderstandings. A very good introduction to domain modeling is (Tomassetti, 2017) .","title":"Motivation"},{"location":"motivation/#mdsd-and-dsls","text":"Model driven software development (MDSD) allows introducing a supplementary layer of abstraction above the code: This additional complexity can be employed to complement, and in some cases replace traditional model based design approaches, and thus represents a significant design element of a software architecture. Such model driven approaches often also refer to domain specific languages (DSL) . These languages make the design easy to communicate (defined language at design level) and at the same time the design itself constitutes of actual software artifacts, since code is directly generated from it (single source of information).","title":"MDSD and DSLs"},{"location":"motivation/#meta-model-model-and-all-that","text":"The meta modeling toolsets utilized on this site typically allow to define (1) a meta model , which defines what is modeled, e.g., the basic layout of a data structure in terms of structures which have attributes. This meta model can be compared to a data base layout . It also can be compared to glossary for a given domain. Using the meta model (2) model data can be defined by a user. This model data represents the concrete data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate and check concrete models. Finally, (4) code generators and model transformations represent primary end user tools to allow mass production based on a single source of information (the model).","title":"Meta-model, model, and all that"},{"location":"motivation/#real-value-for-a-project","text":"Notably, if a model represents a real abstraction of a software aspect - something people talk about and which hides important details - we get a big impact in productivity. From the one and single source of specification (the model data) we can extract documentation, plan and archive changes (in the models) and at the same time guarantee the consistency of model and multiple code artifacts. The real value in terms of working hours is not the meta model, the code generator or the editor of a model, but the model data itself. The rest of the employed toolset and definitions (e.g. the meta model) further increase this value, by allowing to validate, transform or evaluate the model data. Keeping this in mind, one should be able to parse and understand the model data in, say, 10 years. Also think about what happens if multiple users create conflicts in model files. One should be able to repair such situations. This is easier if the model stored on disk resembles the model entered by the user, than if an alternative representation is used with, e.g., binary data representations or machine generated IDs which are difficult to understand. Such a simple representation on disk also allows to easily analyze a model with a traditional text search tool (grep) and to make quick modifications to the model with a simple editor. Moreover, the interoperability of employed toolsets is of crucial importancy: the ability to define inter-model relations eases large scale model driven approaches and the IDE integration increases end user acceptance.","title":"Real value for a project"},{"location":"references/","text":"References Many websites, books and persons influenced this work. The references are summarized in the following sections. Toolsets / Language Workbenches (Xtext) Xtext - a grammar based language workbench for java/Xtend/eclipse. (TextX) TextX - a grammar based language workbench for Python. Programming languages, Tools (Maven) Maven - a build system Xtend - a statically types language (translates to Java). Python - a dynamically types language. (Xtend Help) Eclipse/Help/\"Help Contents\"/\"Xtend User Guide\". General information (Tomassetti, 2017) F. Tomassetti: \"The complete guide to (external) Domain Specific Languages\" (06/2018) Xtext related stuff (Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016). (Mooij et al, 2017a) A. Mooij, J. Hooman: \"Creating a Domain Specific Language (DSL) with Xtext\" (2017/06) (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman: \"Advanced Xtext Manual on Modularity\" (2017/06) (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05; architect of eTrice (ROOM based modeling tool) (2017/06) (Xtext 15 Minutes Tutorial) Xtext 15 Minutes Tutorial . (Xtext 15 Minutes Tutorial, Extended) Xtext 15 Minutes Tutorial, Extended . (Xtext Help) Eclipse/Help/\"Help Contents\"/\"Xtext Documentation\". TextX related stuff (Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.","title":"References"},{"location":"references/#references","text":"Many websites, books and persons influenced this work. The references are summarized in the following sections.","title":"References"},{"location":"references/#toolsets-language-workbenches","text":"(Xtext) Xtext - a grammar based language workbench for java/Xtend/eclipse. (TextX) TextX - a grammar based language workbench for Python.","title":"Toolsets / Language Workbenches"},{"location":"references/#programming-languages-tools","text":"(Maven) Maven - a build system Xtend - a statically types language (translates to Java). Python - a dynamically types language. (Xtend Help) Eclipse/Help/\"Help Contents\"/\"Xtend User Guide\".","title":"Programming languages, Tools"},{"location":"references/#general-information","text":"(Tomassetti, 2017) F. Tomassetti: \"The complete guide to (external) Domain Specific Languages\" (06/2018)","title":"General information"},{"location":"references/#xtext-related-stuff","text":"(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016). (Mooij et al, 2017a) A. Mooij, J. Hooman: \"Creating a Domain Specific Language (DSL) with Xtext\" (2017/06) (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman: \"Advanced Xtext Manual on Modularity\" (2017/06) (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05; architect of eTrice (ROOM based modeling tool) (2017/06) (Xtext 15 Minutes Tutorial) Xtext 15 Minutes Tutorial . (Xtext 15 Minutes Tutorial, Extended) Xtext 15 Minutes Tutorial, Extended . (Xtext Help) Eclipse/Help/\"Help Contents\"/\"Xtext Documentation\".","title":"Xtext related stuff"},{"location":"references/#textx-related-stuff","text":"(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.","title":"TextX related stuff"},{"location":"textx_by_examples/","text":"TextX by Examples The TextX project page gives a nice introduction to the concepts of TextX (TextX) . Read the docs to explore different aspects, like the grammar or scoping. The unittests are also a great source of information, because they contain many examples for different topics. Note: validators are implemented as so-called object_processors. These object_processors are meant to post process the parsed model (possibly modifying the model). They can also be used to raise exceptions in order to indicate a logical domain error (as in the initial example ).","title":"TextX by Examples"},{"location":"textx_by_examples/#textx-by-examples","text":"The TextX project page gives a nice introduction to the concepts of TextX (TextX) . Read the docs to explore different aspects, like the grammar or scoping. The unittests are also a great source of information, because they contain many examples for different topics. Note: validators are implemented as so-called object_processors. These object_processors are meant to post process the parsed model (possibly modifying the model). They can also be used to raise exceptions in order to indicate a logical domain error (as in the initial example ).","title":"TextX by Examples"},{"location":"textx_intro/","text":"TextX Intro TextX is a Python library to allow an easy creation of DSL validators and artifact generators: Reading model files ( grammar based parsing , reference resolution and post processing). Validating the model . Generating output artifacts (e.g., code). A fundamental difference to Xtext is that the meta model classes (describing the model elements) are dynamically generated instead of generating code from them. Thus, a grammar in TextX in interpreted dynamically and not compiled. TextX has only few dependencies and very compact projects can be created. Details see (Dejanovi\u0107 et al. 2017) and the \"TextX project page\", see (TextX) . TextX itself is permanently tested with different python versions. Normally, a similar modularization as for Xtext projects is employed to separate different responsibilities across software modules (e.g. modules for the grammar , validation , and code generation ). However, it is possible to put an entire project including grammar and the validation into one file: the following code illustrates a meta model with an example model which is validated (similar to the example in the introductory example of validation ). from textx import metamodel_from_str from textx.scoping.providers import RelativeName , FQN from textx.export import model_export # ------------------------------------ # GRAMMAR # meta_model = metamodel_from_str ( ''' Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase; Scenario: 'SCENARIO' name=ID 'BEGIN' configs+=Config 'END'; Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')'; Aspect: 'ASPECT' name=ID; Testcase: 'TESTCASE' name=ID 'BEGIN' 'USES' scenario=[Scenario] 'WITH' config=[Config] 'NEEDS' '(' needs*=[Aspect] ')' 'END'; Comment: /\\/\\/.*/; ''' ) # ------------------------------------ # SCOPING # meta_model . register_scope_providers ({ '*.*' : FQN (), 'Testcase.config' : RelativeName ( 'scenario.configs' ) }) # ------------------------------------ # VALIDATION # def check_testcase ( testcase ): \"\"\" checks that the config used by the testcase fulfills its needs \"\"\" for need in testcase . needs : if need not in testcase . config . haves : raise Exception ( \"{}: {} not found in {}.{}\" . format ( testcase . name , need . name , testcase . scenario . name , testcase . config . name )) meta_model . register_obj_processors ({ 'Testcase' : check_testcase }) # ------------------------------------ # EXAMPLE # model = meta_model . model_from_str ( ''' ASPECT NetworkTraffic ASPECT FileAccess SCENARIO S001 BEGIN CONFIG HeavyNetworkTraffic HAS (NetworkTraffic) CONFIG NoNetworkTraffic HAS () END SCENARIO S002 BEGIN CONFIG WithFileAccess HAS (NetworkTraffic FileAccess) CONFIG NoFileAccess HAS (NetworkTraffic) END TESTCASE T001 BEGIN USES S001 WITH HeavyNetworkTraffic NEEDS (NetworkTraffic) END TESTCASE T002 BEGIN //USES S001 WITH NoNetworkTraffic // Error USES S002 WITH NoFileAccess NEEDS (NetworkTraffic) END ''' ) model_export ( model , 'model.dot' )","title":"TextX Intro"},{"location":"textx_intro/#textx-intro","text":"TextX is a Python library to allow an easy creation of DSL validators and artifact generators: Reading model files ( grammar based parsing , reference resolution and post processing). Validating the model . Generating output artifacts (e.g., code). A fundamental difference to Xtext is that the meta model classes (describing the model elements) are dynamically generated instead of generating code from them. Thus, a grammar in TextX in interpreted dynamically and not compiled. TextX has only few dependencies and very compact projects can be created. Details see (Dejanovi\u0107 et al. 2017) and the \"TextX project page\", see (TextX) . TextX itself is permanently tested with different python versions. Normally, a similar modularization as for Xtext projects is employed to separate different responsibilities across software modules (e.g. modules for the grammar , validation , and code generation ). However, it is possible to put an entire project including grammar and the validation into one file: the following code illustrates a meta model with an example model which is validated (similar to the example in the introductory example of validation ). from textx import metamodel_from_str from textx.scoping.providers import RelativeName , FQN from textx.export import model_export # ------------------------------------ # GRAMMAR # meta_model = metamodel_from_str ( ''' Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase; Scenario: 'SCENARIO' name=ID 'BEGIN' configs+=Config 'END'; Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')'; Aspect: 'ASPECT' name=ID; Testcase: 'TESTCASE' name=ID 'BEGIN' 'USES' scenario=[Scenario] 'WITH' config=[Config] 'NEEDS' '(' needs*=[Aspect] ')' 'END'; Comment: /\\/\\/.*/; ''' ) # ------------------------------------ # SCOPING # meta_model . register_scope_providers ({ '*.*' : FQN (), 'Testcase.config' : RelativeName ( 'scenario.configs' ) }) # ------------------------------------ # VALIDATION # def check_testcase ( testcase ): \"\"\" checks that the config used by the testcase fulfills its needs \"\"\" for need in testcase . needs : if need not in testcase . config . haves : raise Exception ( \"{}: {} not found in {}.{}\" . format ( testcase . name , need . name , testcase . scenario . name , testcase . config . name )) meta_model . register_obj_processors ({ 'Testcase' : check_testcase }) # ------------------------------------ # EXAMPLE # model = meta_model . model_from_str ( ''' ASPECT NetworkTraffic ASPECT FileAccess SCENARIO S001 BEGIN CONFIG HeavyNetworkTraffic HAS (NetworkTraffic) CONFIG NoNetworkTraffic HAS () END SCENARIO S002 BEGIN CONFIG WithFileAccess HAS (NetworkTraffic FileAccess) CONFIG NoFileAccess HAS (NetworkTraffic) END TESTCASE T001 BEGIN USES S001 WITH HeavyNetworkTraffic NEEDS (NetworkTraffic) END TESTCASE T002 BEGIN //USES S001 WITH NoNetworkTraffic // Error USES S002 WITH NoFileAccess NEEDS (NetworkTraffic) END ''' ) model_export ( model , 'model.dot' )","title":"TextX Intro"},{"location":"textx_modularization/","text":"TextX: Model Modularization Similar to xtext_modularization.md , we show how to achive model modularization across files in TextX. Modularization within the same Meta Model Ready to use scope providers exists to handle multiple files. See the (TextX) documentation for details. Referencing Model Elements form other Meta Models If you wish to reference model elements from other metamodels, this can be achieved using the multi meta model support of TextX (see (TextX) ). The following example is self contained and shows how to deploy two python packages for two DSLs, one referencing the other. mydsl : a simple \"Hello World\" language mydsl1 : a language referencing Greetings from the mydsl language. mydsl - a simple model of \"Greetings\" File layout \u251c\u2500\u2500 mydsl \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 metamodel.py \u2502 \u2514\u2500\u2500 MyDsl.tx \u2514\u2500\u2500 setup.py Grammar MyDsl.tx The grammar defines the structure... Model : greetings += Greeting ; Greeting : 'Hello' name = ID '!' ; metamodel.py The metamodel is created based on the grammar... from textx import metamodel_from_file from os.path import dirname , abspath , join def get_metamodel (): this_folder = dirname ( abspath ( __file__ )) meta_model = metamodel_from_file ( join ( this_folder , \"MyDsl.tx\" )) return meta_model __init__.py The entry point for the DSL \"compiler\" (it just outputs some model data)... import argparse from mydsl.metamodel import get_metamodel def mydslc (): parser = argparse . ArgumentParser ( description = 'generate code for the model.' ) parser . add_argument ( 'model_files' , metavar = 'model_files' , type = str , nargs = '+' , help = 'model filenames' ) args = parser . parse_args () mm = get_metamodel () for model_file in args . model_files : model = mm . model_from_file ( model_file ) for greeting in model . greetings : print ( \" - hello for '{}'\" . format ( greeting . name )) setup.py The installer configuration (see textx_project_setupx.md for more details). ... setup ( name = 'mydsl' , ... entry_points = { 'console_scripts' : [ 'mydslc=mydsl:mydslc' , ] }, ... Create installer Create an installer to help pip find its dependencies: python setup.py sdist mydsl1 - a model referencing the \"Greetings\" from mydsl File layout \u251c\u2500\u2500 mydsl1 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 metamodel.py \u2502 \u2514\u2500\u2500 MyDsl1.tx \u2514\u2500\u2500 setup.py Grammar MyDsl1.tx Note: we use the grammar rule \"Greeting\" from \"mydsl\". See metamodel.py how this is resolved (\"refrenced_metamodels\"). Model : imports += Import greetings += RefGreeting ; RefGreeting : 'Hello' '-->' ref = [ Greeting ]; Import : 'import' importURI = STRING ; metamodel.py The metamodel is created based on the grammar, the metamodel to be referenced and some scope providers (to allow to \"import\" other model files)... from textx import metamodel_from_file import textx.scoping as scoping import textx.scoping.providers as scoping_providers from os.path import dirname , abspath , join import mydsl def get_metamodel (): this_folder = dirname ( abspath ( __file__ )) # get the \"mydsl\" meta model other_meta_model = mydsl . get_metamodel () # create the meta model and reference \"mydsl\" meta_model = metamodel_from_file ( join ( this_folder , \"MyDsl1.tx\" ), referenced_metamodels = [ other_meta_model ]) # register scope provider (allow import models into mydsl1 models) meta_model . register_scope_providers ( { \"*.*\" : scoping_providers . PlainNameImportURI ()}) # register file endings scoping . MetaModelProvider . add_metamodel ( \"*.mydsl\" , other_meta_model ) scoping . MetaModelProvider . add_metamodel ( \"*.mydsl1\" , meta_model ) return meta_model __init__.py The entry point for the DSL \"compiler\" (it just outputs some model data)... import argparse from mydsl1.metamodel import get_metamodel def mydsl1c (): parser = argparse . ArgumentParser ( description = 'generate code for the model.' ) parser . add_argument ( 'model_files' , metavar = 'model_files' , type = str , nargs = '+' , help = 'model filenames' ) args = parser . parse_args () mm = get_metamodel () for model_file in args . model_files : model = mm . model_from_file ( model_file ) for greeting in model . greetings : print ( \" - hello for referenced '{}'\" . format ( greeting . ref . name )) setup.py The installer configuration (see textx_project_setupx.md for more details). The language \"mydsl1\" depends on \"mydsl\". ... setup ( name = 'mydsl1' , ... install_requires = [ \"textx\" , \"arpeggio\" , \"mydsl\" ], ... entry_points = { 'console_scripts' : [ 'mydsl1c=mydsl1:mydsl1c' , ] }, ... Usage Install both DSLs and compilers The option \"find-links\" is used to point to the local version of mydsl (created above; setup.py of \"mydsl1\" includes this dependency): pip3 install . --find-links = file:/// $( pwd ) /../mydsl/dist Model file data.mydsl Hello Pi ! Hello Tim ! Model file data.mydsl1 import \" data.mydsl \" Hello --> Pi Hello --> Tim Model file error.mydsl1 import \" data.mydsl \" Hello --> NoName Example using mydslc and mydsl1c $ mydslc model/data.mydsl - hello for 'Pi' - hello for 'Tim' $ mydsl1c model/data.mydsl1 - hello for referenced 'Pi' - hello for referenced 'Tim' $ mydsl1c model/error.mydsl1 ... textx.exceptions.TextXSemanticError: model/error.mydsl1:2:11: error: Unknown object \"NoName\" of class \"Greeting\"","title":"TextX Modularization"},{"location":"textx_modularization/#textx-model-modularization","text":"Similar to xtext_modularization.md , we show how to achive model modularization across files in TextX.","title":"TextX: Model Modularization"},{"location":"textx_modularization/#modularization-within-the-same-meta-model","text":"Ready to use scope providers exists to handle multiple files. See the (TextX) documentation for details.","title":"Modularization within the same Meta Model"},{"location":"textx_modularization/#referencing-model-elements-form-other-meta-models","text":"If you wish to reference model elements from other metamodels, this can be achieved using the multi meta model support of TextX (see (TextX) ). The following example is self contained and shows how to deploy two python packages for two DSLs, one referencing the other. mydsl : a simple \"Hello World\" language mydsl1 : a language referencing Greetings from the mydsl language.","title":"Referencing Model Elements form other Meta Models"},{"location":"textx_modularization/#mydsl-a-simple-model-of-greetings","text":"","title":"mydsl - a simple model of \"Greetings\""},{"location":"textx_modularization/#file-layout","text":"\u251c\u2500\u2500 mydsl \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 metamodel.py \u2502 \u2514\u2500\u2500 MyDsl.tx \u2514\u2500\u2500 setup.py","title":"File layout"},{"location":"textx_modularization/#grammar-mydsltx","text":"The grammar defines the structure... Model : greetings += Greeting ; Greeting : 'Hello' name = ID '!' ;","title":"Grammar MyDsl.tx"},{"location":"textx_modularization/#metamodelpy","text":"The metamodel is created based on the grammar... from textx import metamodel_from_file from os.path import dirname , abspath , join def get_metamodel (): this_folder = dirname ( abspath ( __file__ )) meta_model = metamodel_from_file ( join ( this_folder , \"MyDsl.tx\" )) return meta_model","title":"metamodel.py"},{"location":"textx_modularization/#9595init9595py","text":"The entry point for the DSL \"compiler\" (it just outputs some model data)... import argparse from mydsl.metamodel import get_metamodel def mydslc (): parser = argparse . ArgumentParser ( description = 'generate code for the model.' ) parser . add_argument ( 'model_files' , metavar = 'model_files' , type = str , nargs = '+' , help = 'model filenames' ) args = parser . parse_args () mm = get_metamodel () for model_file in args . model_files : model = mm . model_from_file ( model_file ) for greeting in model . greetings : print ( \" - hello for '{}'\" . format ( greeting . name ))","title":"__init__.py"},{"location":"textx_modularization/#setuppy","text":"The installer configuration (see textx_project_setupx.md for more details). ... setup ( name = 'mydsl' , ... entry_points = { 'console_scripts' : [ 'mydslc=mydsl:mydslc' , ] }, ...","title":"setup.py"},{"location":"textx_modularization/#create-installer","text":"Create an installer to help pip find its dependencies: python setup.py sdist","title":"Create installer"},{"location":"textx_modularization/#mydsl1-a-model-referencing-the-greetings-from-mydsl","text":"","title":"mydsl1 - a model referencing the \"Greetings\" from mydsl"},{"location":"textx_modularization/#file-layout_1","text":"\u251c\u2500\u2500 mydsl1 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 metamodel.py \u2502 \u2514\u2500\u2500 MyDsl1.tx \u2514\u2500\u2500 setup.py","title":"File layout"},{"location":"textx_modularization/#grammar-mydsl1tx","text":"Note: we use the grammar rule \"Greeting\" from \"mydsl\". See metamodel.py how this is resolved (\"refrenced_metamodels\"). Model : imports += Import greetings += RefGreeting ; RefGreeting : 'Hello' '-->' ref = [ Greeting ]; Import : 'import' importURI = STRING ;","title":"Grammar MyDsl1.tx"},{"location":"textx_modularization/#metamodelpy_1","text":"The metamodel is created based on the grammar, the metamodel to be referenced and some scope providers (to allow to \"import\" other model files)... from textx import metamodel_from_file import textx.scoping as scoping import textx.scoping.providers as scoping_providers from os.path import dirname , abspath , join import mydsl def get_metamodel (): this_folder = dirname ( abspath ( __file__ )) # get the \"mydsl\" meta model other_meta_model = mydsl . get_metamodel () # create the meta model and reference \"mydsl\" meta_model = metamodel_from_file ( join ( this_folder , \"MyDsl1.tx\" ), referenced_metamodels = [ other_meta_model ]) # register scope provider (allow import models into mydsl1 models) meta_model . register_scope_providers ( { \"*.*\" : scoping_providers . PlainNameImportURI ()}) # register file endings scoping . MetaModelProvider . add_metamodel ( \"*.mydsl\" , other_meta_model ) scoping . MetaModelProvider . add_metamodel ( \"*.mydsl1\" , meta_model ) return meta_model","title":"metamodel.py"},{"location":"textx_modularization/#9595init9595py_1","text":"The entry point for the DSL \"compiler\" (it just outputs some model data)... import argparse from mydsl1.metamodel import get_metamodel def mydsl1c (): parser = argparse . ArgumentParser ( description = 'generate code for the model.' ) parser . add_argument ( 'model_files' , metavar = 'model_files' , type = str , nargs = '+' , help = 'model filenames' ) args = parser . parse_args () mm = get_metamodel () for model_file in args . model_files : model = mm . model_from_file ( model_file ) for greeting in model . greetings : print ( \" - hello for referenced '{}'\" . format ( greeting . ref . name ))","title":"__init__.py"},{"location":"textx_modularization/#setuppy_1","text":"The installer configuration (see textx_project_setupx.md for more details). The language \"mydsl1\" depends on \"mydsl\". ... setup ( name = 'mydsl1' , ... install_requires = [ \"textx\" , \"arpeggio\" , \"mydsl\" ], ... entry_points = { 'console_scripts' : [ 'mydsl1c=mydsl1:mydsl1c' , ] }, ...","title":"setup.py"},{"location":"textx_modularization/#usage","text":"","title":"Usage"},{"location":"textx_modularization/#install-both-dsls-and-compilers","text":"The option \"find-links\" is used to point to the local version of mydsl (created above; setup.py of \"mydsl1\" includes this dependency): pip3 install . --find-links = file:/// $( pwd ) /../mydsl/dist","title":"Install both DSLs and compilers"},{"location":"textx_modularization/#model-file-datamydsl","text":"Hello Pi ! Hello Tim !","title":"Model file data.mydsl"},{"location":"textx_modularization/#model-file-datamydsl1","text":"import \" data.mydsl \" Hello --> Pi Hello --> Tim","title":"Model file data.mydsl1"},{"location":"textx_modularization/#model-file-errormydsl1","text":"import \" data.mydsl \" Hello --> NoName","title":"Model file error.mydsl1"},{"location":"textx_modularization/#example-using-mydslc-and-mydsl1c","text":"$ mydslc model/data.mydsl - hello for 'Pi' - hello for 'Tim' $ mydsl1c model/data.mydsl1 - hello for referenced 'Pi' - hello for referenced 'Tim' $ mydsl1c model/error.mydsl1 ... textx.exceptions.TextXSemanticError: model/error.mydsl1:2:11: error: Unknown object \"NoName\" of class \"Greeting\"","title":"Example using mydslc and mydsl1c"},{"location":"textx_project_setup/","text":"TextX Project Setup We give a guide to create a simple command line tool to load and validate a model and to generate some artifact. In this example, we propose different models for the meta model structure (grammar), the scoping , and the artifact generation . Moreover, a main and a setup script are added to control the software. For this example we use Python 3. You need to install TextX (see references ). Arpeggio (see TextX in references ) pytest (for unittests) Using pip you can: pip3 install --upgrade textx arpeggio pytest File structure Although everything can be packed within one file (see \"TextX Intro\" ), the code is better structured into different modules with individual responsibilities into different files. \u251c\u2500\u2500 setup.py \u251c\u2500\u2500 simple_dsl \u2502 \u251c\u2500\u2500 codegen.py \u2502 \u251c\u2500\u2500 console \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 validate.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 metamodel.py \u2502 \u2514\u2500\u2500 validation.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 model_not_ok.dsl \u2502 \u2514\u2500\u2500 model_ok.dsl \u2514\u2500\u2500 test_validation.py We have chosen a distribution as follows: setup.py is the standard python project configuration simple_dsl contain all dsl related logic: codegen.py: code generation. metamodel.py: the meta model (grammar, scoping and validation config; the user classes are also stored here but could be moved elsewhere for more complex projects. validation.py: validation logic. console/*.py: console programs (configured in setup.py). __init__.py represent module entry points. tests contains unittests. File: metamodel.py Here, we define the grammar. We allocate the scope providers to individual elements, and register validation code. from textx import metamodel_from_str from textx.scoping.providers import RelativeName , FQN import simple_dsl.validation as validation def get_metamodel (): # GRAMMAR # (you also use metamodel_from_file with a *.tx file) meta_model = metamodel_from_str ( ''' Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase; Scenario: 'SCENARIO' name=ID 'BEGIN' configs+=Config 'END'; Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')'; Aspect: 'ASPECT' name=ID; Testcase: 'TESTCASE' name=ID 'BEGIN' 'USES' scenario=[Scenario] 'WITH' config=[Config] 'NEEDS' '(' needs*=[Aspect] ')' 'END'; Comment: /\\/\\/.*/; ''' ) # SCOPING meta_model . register_scope_providers ({ '*.*' : FQN (), 'Testcase.config' : RelativeName ( 'scenario.configs' ) }) # ADD VALIDATION meta_model . register_obj_processors ({ 'Testcase' : validation . check_testcase }) return meta_model File: validation.py This file contains validation functions registered in the meta model. from textx.exceptions import TextXError from textx.scoping.tools import get_location def check_testcase ( testcase ): \"\"\" checks that the config used by the testcase fulfills its needs \"\"\" for need in testcase . needs : if need not in testcase . config . haves : raise ( TextXError ( \"{}: {} not found in {}.{}\" . format ( testcase . name , need . name , testcase . scenario . name , testcase . config . name ), ** get_location ( testcase ) # unpack location info )) File: tests/test_validation.py This file is a unittest using the metamodel (exposed via __init__.py) and checks the correct functionality of the validation code. from pytest import raises from simple_dsl import get_metamodel from os.path import dirname , join from textx import get_children_of_type def test_validation_ok (): mm = get_metamodel () m = mm . model_from_file ( join ( dirname ( __file__ ), 'models' , 'model_ok.dsl' )) assert 2 == len ( get_children_of_type ( 'Aspect' , m )) def test_validation_not_ok (): mm = get_metamodel () with raises ( Exception , match = r 'NetworkTraffic.*not found.*S001.*NoNetworkTraffic' ): _ = mm . model_from_file ( join ( dirname ( __file__ ), 'models' , 'model_not_ok.dsl' )) The two model files used in this tests are shown in the following subsections. Model: tests/models/model_ok.dsl ASPECT NetworkTraffic ASPECT FileAccess SCENARIO S001 BEGIN CONFIG HeavyNetworkTraffic HAS ( NetworkTraffic ) CONFIG NoNetworkTraffic HAS () END SCENARIO S002 BEGIN CONFIG WithFileAccess HAS ( NetworkTraffic FileAccess ) CONFIG NoFileAccess HAS ( NetworkTraffic ) END TESTCASE T001 BEGIN USES S001 WITH HeavyNetworkTraffic NEEDS ( NetworkTraffic ) END TESTCASE T002 BEGIN USES S001 WITH NoNetworkTraffic // Error //USES S002 WITH NoFileAccess NEEDS ( NetworkTraffic ) END Model: tests/models/model_not_ok.dsl ASPECT NetworkTraffic ASPECT FileAccess SCENARIO S001 BEGIN CONFIG HeavyNetworkTraffic HAS ( NetworkTraffic ) CONFIG NoNetworkTraffic HAS () END SCENARIO S002 BEGIN CONFIG WithFileAccess HAS ( NetworkTraffic FileAccess ) CONFIG NoFileAccess HAS ( NetworkTraffic ) END TESTCASE T001 BEGIN USES S001 WITH HeavyNetworkTraffic NEEDS ( NetworkTraffic ) END TESTCASE T002 BEGIN //USES S001 WITH NoNetworkTraffic // Error USES S002 WITH NoFileAccess NEEDS ( NetworkTraffic ) END Edit, Run and Test Use an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your new language. Install/Uninstall the Language After all tests passed you can try to install your language. Do not forget to adapt setup.py: from setuptools import setup , find_packages setup ( name = 'simple_dsl' , version = '0.1' , description = 'a simple model validator and artifact compiler' , url = '' , author = 'YOUR NAME' , author_email = 'YOUR.NAME@ADDRESS' , license = 'TODO' , packages = find_packages (), package_data = { '' : [ '*.tx' , '*.template' , 'support_*_code/**/*' ]}, install_requires = [ \"textx\" , \"arpeggio\" ], tests_require = [ 'pytest' , ], keywords = \"parser meta-language meta-model language DSL\" , entry_points = { 'console_scripts' : [ 'simple_dsl_validate=simple_dsl.console.validate:validate' , ] }, ) # to play around without installing: do \"export PYTHONPATH=.\" The registered console command (validate.py) contains: import argparse from simple_dsl import get_metamodel def validate (): mm = get_metamodel () parser = argparse . ArgumentParser ( description = 'validate simple_dsl files.' ) parser . add_argument ( 'model_files' , metavar = 'model_files' , type = str , nargs = '+' , help = 'model filenames' ) args = parser . parse_args () for filename in args . model_files : try : print ( 'validating {}' . format ( filename )) _ = mm . model_from_file ( filename ) except BaseException as e : print ( ' WARNING/ERROR: {}' . format ( e )) if __name__ == '__main__' : validate () Installation Install the software permanently for all users (change directory to the folder with the setup.py file): sudo -H pip3 install --upgrade . You can now start the new commands defined in the setup.py: simple_dsl_validate --help Uninstallation Uninstall the software: sudo -H pip3 uninstall simple_dsl","title":"TextX Project Setup"},{"location":"textx_project_setup/#textx-project-setup","text":"We give a guide to create a simple command line tool to load and validate a model and to generate some artifact. In this example, we propose different models for the meta model structure (grammar), the scoping , and the artifact generation . Moreover, a main and a setup script are added to control the software. For this example we use Python 3. You need to install TextX (see references ). Arpeggio (see TextX in references ) pytest (for unittests) Using pip you can: pip3 install --upgrade textx arpeggio pytest","title":"TextX Project Setup"},{"location":"textx_project_setup/#file-structure","text":"Although everything can be packed within one file (see \"TextX Intro\" ), the code is better structured into different modules with individual responsibilities into different files. \u251c\u2500\u2500 setup.py \u251c\u2500\u2500 simple_dsl \u2502 \u251c\u2500\u2500 codegen.py \u2502 \u251c\u2500\u2500 console \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u2514\u2500\u2500 validate.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 metamodel.py \u2502 \u2514\u2500\u2500 validation.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 model_not_ok.dsl \u2502 \u2514\u2500\u2500 model_ok.dsl \u2514\u2500\u2500 test_validation.py We have chosen a distribution as follows: setup.py is the standard python project configuration simple_dsl contain all dsl related logic: codegen.py: code generation. metamodel.py: the meta model (grammar, scoping and validation config; the user classes are also stored here but could be moved elsewhere for more complex projects. validation.py: validation logic. console/*.py: console programs (configured in setup.py). __init__.py represent module entry points. tests contains unittests.","title":"File structure"},{"location":"textx_project_setup/#file-metamodelpy","text":"Here, we define the grammar. We allocate the scope providers to individual elements, and register validation code. from textx import metamodel_from_str from textx.scoping.providers import RelativeName , FQN import simple_dsl.validation as validation def get_metamodel (): # GRAMMAR # (you also use metamodel_from_file with a *.tx file) meta_model = metamodel_from_str ( ''' Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase; Scenario: 'SCENARIO' name=ID 'BEGIN' configs+=Config 'END'; Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')'; Aspect: 'ASPECT' name=ID; Testcase: 'TESTCASE' name=ID 'BEGIN' 'USES' scenario=[Scenario] 'WITH' config=[Config] 'NEEDS' '(' needs*=[Aspect] ')' 'END'; Comment: /\\/\\/.*/; ''' ) # SCOPING meta_model . register_scope_providers ({ '*.*' : FQN (), 'Testcase.config' : RelativeName ( 'scenario.configs' ) }) # ADD VALIDATION meta_model . register_obj_processors ({ 'Testcase' : validation . check_testcase }) return meta_model","title":"File: "},{"location":"textx_project_setup/#file-validationpy","text":"This file contains validation functions registered in the meta model. from textx.exceptions import TextXError from textx.scoping.tools import get_location def check_testcase ( testcase ): \"\"\" checks that the config used by the testcase fulfills its needs \"\"\" for need in testcase . needs : if need not in testcase . config . haves : raise ( TextXError ( \"{}: {} not found in {}.{}\" . format ( testcase . name , need . name , testcase . scenario . name , testcase . config . name ), ** get_location ( testcase ) # unpack location info ))","title":"File: "},{"location":"textx_project_setup/#file-teststest_validationpy","text":"This file is a unittest using the metamodel (exposed via __init__.py) and checks the correct functionality of the validation code. from pytest import raises from simple_dsl import get_metamodel from os.path import dirname , join from textx import get_children_of_type def test_validation_ok (): mm = get_metamodel () m = mm . model_from_file ( join ( dirname ( __file__ ), 'models' , 'model_ok.dsl' )) assert 2 == len ( get_children_of_type ( 'Aspect' , m )) def test_validation_not_ok (): mm = get_metamodel () with raises ( Exception , match = r 'NetworkTraffic.*not found.*S001.*NoNetworkTraffic' ): _ = mm . model_from_file ( join ( dirname ( __file__ ), 'models' , 'model_not_ok.dsl' )) The two model files used in this tests are shown in the following subsections.","title":"File: tests/test_validation.py"},{"location":"textx_project_setup/#model-testsmodelsmodel_okdsl","text":"ASPECT NetworkTraffic ASPECT FileAccess SCENARIO S001 BEGIN CONFIG HeavyNetworkTraffic HAS ( NetworkTraffic ) CONFIG NoNetworkTraffic HAS () END SCENARIO S002 BEGIN CONFIG WithFileAccess HAS ( NetworkTraffic FileAccess ) CONFIG NoFileAccess HAS ( NetworkTraffic ) END TESTCASE T001 BEGIN USES S001 WITH HeavyNetworkTraffic NEEDS ( NetworkTraffic ) END TESTCASE T002 BEGIN USES S001 WITH NoNetworkTraffic // Error //USES S002 WITH NoFileAccess NEEDS ( NetworkTraffic ) END","title":"Model: tests/models/model_ok.dsl"},{"location":"textx_project_setup/#model-testsmodelsmodel_not_okdsl","text":"ASPECT NetworkTraffic ASPECT FileAccess SCENARIO S001 BEGIN CONFIG HeavyNetworkTraffic HAS ( NetworkTraffic ) CONFIG NoNetworkTraffic HAS () END SCENARIO S002 BEGIN CONFIG WithFileAccess HAS ( NetworkTraffic FileAccess ) CONFIG NoFileAccess HAS ( NetworkTraffic ) END TESTCASE T001 BEGIN USES S001 WITH HeavyNetworkTraffic NEEDS ( NetworkTraffic ) END TESTCASE T002 BEGIN //USES S001 WITH NoNetworkTraffic // Error USES S002 WITH NoFileAccess NEEDS ( NetworkTraffic ) END","title":"Model: tests/models/model_not_ok.dsl"},{"location":"textx_project_setup/#edit-run-and-test","text":"Use an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your new language.","title":"Edit, Run and Test"},{"location":"textx_project_setup/#installuninstall-the-language","text":"After all tests passed you can try to install your language. Do not forget to adapt setup.py: from setuptools import setup , find_packages setup ( name = 'simple_dsl' , version = '0.1' , description = 'a simple model validator and artifact compiler' , url = '' , author = 'YOUR NAME' , author_email = 'YOUR.NAME@ADDRESS' , license = 'TODO' , packages = find_packages (), package_data = { '' : [ '*.tx' , '*.template' , 'support_*_code/**/*' ]}, install_requires = [ \"textx\" , \"arpeggio\" ], tests_require = [ 'pytest' , ], keywords = \"parser meta-language meta-model language DSL\" , entry_points = { 'console_scripts' : [ 'simple_dsl_validate=simple_dsl.console.validate:validate' , ] }, ) # to play around without installing: do \"export PYTHONPATH=.\" The registered console command (validate.py) contains: import argparse from simple_dsl import get_metamodel def validate (): mm = get_metamodel () parser = argparse . ArgumentParser ( description = 'validate simple_dsl files.' ) parser . add_argument ( 'model_files' , metavar = 'model_files' , type = str , nargs = '+' , help = 'model filenames' ) args = parser . parse_args () for filename in args . model_files : try : print ( 'validating {}' . format ( filename )) _ = mm . model_from_file ( filename ) except BaseException as e : print ( ' WARNING/ERROR: {}' . format ( e )) if __name__ == '__main__' : validate ()","title":"Install/Uninstall the Language"},{"location":"textx_project_setup/#installation","text":"Install the software permanently for all users (change directory to the folder with the setup.py file): sudo -H pip3 install --upgrade . You can now start the new commands defined in the setup.py: simple_dsl_validate --help","title":"Installation"},{"location":"textx_project_setup/#uninstallation","text":"Uninstall the software: sudo -H pip3 uninstall simple_dsl","title":"Uninstallation"},{"location":"xtext_a_first_grammar/","text":"A First Grammar Here we highlight some information when walking through (Xtext 15 Minutes Tutorial) . Goal In this section you will learn How to model hierarchical data structures (things containing things). How to model references (things referencing things). How to identify model elements (by name). How to model specialization. Note: How to identify model elements in other hierarchical elements (e.g. packages) will be handled later. Step 1: Create and run an Xtext project Take your time for this tutorial now and continue reading afterwards. You may stop before \"Second Iteration\" where \"packages\" are added to the model. Step 2: Questions Check if you understood thw following points: What is the role of the start rule of a grammar in a meta model? What is the meaning of \"Type: DataType | Entity;\" in terms of inheritance? Explore the generated Java Interfaces for the classes Type, DataType, Entity in src-gen/org/example/domainmodel/domainmodel in your main project. How do you typically add keywords to your language (like \"entity\")? What is the difference between \"x=Rule1\" and \"x=[Rule1]\"? How can you model the following? \"a named University aggregates named Students \". \"a House is composed of Rooms \". Explain the role of \"?\" in the following examples: (x=INT)? enabled?='enabled' Note: Optional attributes can be defined using \"?\". Note: some types, like references, are null if not set. Others have default values (like an empty String for STRING, \"0\" for INT or the first enum value defined for enums). Rules without attributes does not yield an object (e.g.: \"Thing: INT\"). You can force the object creation with the following syntax using curly brackets: \"Thing: {Thing} INT\". Step 3: More examples Can you interpret the following snippet: // ... Model : customers += Customer * computers += Computer * owns += Own * ; Computer : 'computer' name = ID ; Customer : 'customer' name = ID ; Own : 'the' computer = [ Computer ] 'is' 'owned' 'by' customer = [ Customer ] 'since' date = STRING ; What changes, when we define the 'Model' differently: Model : ( customers += Customer computers += Computer owns += Owns )* ; Step 4: Editor In addition to the text editor, you can also edit the model with a tree editor : open the file with \"Open With...\" - \"Sample Ecore Model Editor\". When editing the model graph, the model text is changed accordingly: see the Xtext \"Formatter\" in the online help of Xtext (in the internet or within eclipse): Step 5: Visualize the meta model The ecore model deduced from the grammar can be visualized : see (Mooij et al, 2017a) , section \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c). Moreover a syntax tree can be rendered from the grammar: see (Mooij et al, 2017a) , section \"Optional: View Diagram of Xtext Grammar\" (Window/Show View/Other.../Xtext/Xtext Syntax Graph). Optional Step 6: Adapt you unittests Adapt your unittests. Check some individual model entries (e.g., a name or a list size). You can explore the model structure with the debugger in your unittest (just place a breakpoint and run the test).","title":"A First Grammar"},{"location":"xtext_a_first_grammar/#a-first-grammar","text":"Here we highlight some information when walking through (Xtext 15 Minutes Tutorial) .","title":"A First Grammar"},{"location":"xtext_a_first_grammar/#goal","text":"In this section you will learn How to model hierarchical data structures (things containing things). How to model references (things referencing things). How to identify model elements (by name). How to model specialization. Note: How to identify model elements in other hierarchical elements (e.g. packages) will be handled later.","title":"Goal"},{"location":"xtext_a_first_grammar/#step-1-create-and-run-an-xtext-project","text":"Take your time for this tutorial now and continue reading afterwards. You may stop before \"Second Iteration\" where \"packages\" are added to the model.","title":"Step 1: Create and run an Xtext project"},{"location":"xtext_a_first_grammar/#step-2-questions","text":"Check if you understood thw following points: What is the role of the start rule of a grammar in a meta model? What is the meaning of \"Type: DataType | Entity;\" in terms of inheritance? Explore the generated Java Interfaces for the classes Type, DataType, Entity in src-gen/org/example/domainmodel/domainmodel in your main project. How do you typically add keywords to your language (like \"entity\")? What is the difference between \"x=Rule1\" and \"x=[Rule1]\"? How can you model the following? \"a named University aggregates named Students \". \"a House is composed of Rooms \". Explain the role of \"?\" in the following examples: (x=INT)? enabled?='enabled' Note: Optional attributes can be defined using \"?\". Note: some types, like references, are null if not set. Others have default values (like an empty String for STRING, \"0\" for INT or the first enum value defined for enums). Rules without attributes does not yield an object (e.g.: \"Thing: INT\"). You can force the object creation with the following syntax using curly brackets: \"Thing: {Thing} INT\".","title":"Step 2: Questions"},{"location":"xtext_a_first_grammar/#step-3-more-examples","text":"Can you interpret the following snippet: // ... Model : customers += Customer * computers += Computer * owns += Own * ; Computer : 'computer' name = ID ; Customer : 'customer' name = ID ; Own : 'the' computer = [ Computer ] 'is' 'owned' 'by' customer = [ Customer ] 'since' date = STRING ; What changes, when we define the 'Model' differently: Model : ( customers += Customer computers += Computer owns += Owns )* ;","title":"Step 3: More examples"},{"location":"xtext_a_first_grammar/#step-4-editor","text":"In addition to the text editor, you can also edit the model with a tree editor : open the file with \"Open With...\" - \"Sample Ecore Model Editor\". When editing the model graph, the model text is changed accordingly: see the Xtext \"Formatter\" in the online help of Xtext (in the internet or within eclipse):","title":"Step 4: Editor"},{"location":"xtext_a_first_grammar/#step-5-visualize-the-meta-model","text":"The ecore model deduced from the grammar can be visualized : see (Mooij et al, 2017a) , section \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c). Moreover a syntax tree can be rendered from the grammar: see (Mooij et al, 2017a) , section \"Optional: View Diagram of Xtext Grammar\" (Window/Show View/Other.../Xtext/Xtext Syntax Graph).","title":"Step 5: Visualize the meta model"},{"location":"xtext_a_first_grammar/#optional-step-6-adapt-you-unittests","text":"Adapt your unittests. Check some individual model entries (e.g., a name or a list size). You can explore the model structure with the debugger in your unittest (just place a breakpoint and run the test).","title":"Optional Step 6: Adapt you unittests"},{"location":"xtext_code_generation_xtend/","text":"Code Generation (with Xtend) Xtend is highly optimized to be used for code generation. It has a optimized template engine (e.g., with automatic indentation support) and is fully integrated in the Eclipse IDE (auto completion for model data). Here we highlight some information when walking through (Xtext 15 Minutes Tutorial, Extended) , section \"Writing a Code Generator With Xtend\". Goal of this section You learn how to generate artifacts in form of text files (e.g. source code). You learn how to format the output and how to access model data. After some basic steps you may have a look at xtext_xtend.md to learn more about the language xtend employed for the artifact generator. Finally, you see how you can generate a C++-file based on the model. You will see how you can start from an example code and iteratively replace concrete code with model data. Step 1: Walk through When reading (Xtext 15 Minutes Tutorial, Extended) , start with the first section \"Writing a Code Generator With Xtend\" (until \"Unit Testing the Language\"): Locate the file where the artifact generator is implemented (DomainmodelGenerator.xtend). \" doGenerate \" is the method called when generating artifacts from a model. Ignore the \"IQualifiedNameProvider\": You can just use \"obj.name\" in your example (instead of obj.fullyQualifiedName) for the moment. Xtend allows to use templates (indicated by multiline strings with three single quotes): Inside this templates you can place text which is directly inserted in the output. Special commands like \"IF\" or \"FOR\" can be used if placed between \"\u00ab\" and \"\u00bb\" (\"\u00ab\" and \"\u00bb\" can be entered using CTRL-< and CTRL-> within eclipse). It is also possible to insert local variable values (typically model data, e.g. '''the name of the entity is \u00abentity_var.name\u00bb'''). Tabs are inserted in an intelligent way, such that indentation associated with generator logic (e.g., after an \"\u00abIF\u00bb\") are not inserted into the output (such indentation is visually highlighted in the editor). Optional model elements which are represented as a class are null, when not used. Caution: Other elements, such as enums, INT, and STRING have default values. The example also shows that a modularization is possible (see how code for \"Features\" is inserted). Many aspects may look scary at first sight, but are extremely valuable for the given task of textual artifact generation: See xtext_xtend.md . Note: This following example also illustrates how to get the root of the model (val model=...). This object can be passed to a function generating some text from it. val model = resource . contents . get ( 0 ) as Domainmodel It also shows how to cast an object: \u201eobj as Type\u201c. Step 2: Question What is the following code doing? See xtext_xtend.md . override void doGenerate ( Resource resource , IFileSystemAccess2 fsa , IGeneratorContext context ) { fsa . generateFile ( 'greetings.txt' , 'People to greet: ' + resource . allContents . filter ( Entity ) . map [ name ] . join ( ', ' )) } Step 3: Next step: Extended example Try to generate a C-code snippet: #ifndef __MYSTRUCT_H_ #define __MYSTRUCT_H_ #include <cstdint> struct MyStruct { float attribute1 ; int32_t attribute2 ; }; #endif When starting a new generator snippet, it can help to copy-paste the code to be generate as an example into your code: def generateCppCode ( Entity e ) { ''' #ifndef __MYSTRUCT_H_ #define __MYSTRUCT_H_ #include <cstdint> struct MyStruct { float attribute1; int32_t attribute2; }; #endif ''' } Then start replacing your example code with model information: def generateCppCode ( Entity e ) { ''' #ifndef __MYSTRUCT_H_ // TODO #define __MYSTRUCT_H_ // TODO #include <cstdint> struct \u00ab e . name \u00bb { \u00ab FOR f : e . features \u00bb TODO \u00ab f . name \u00bb; \u00ab ENDFOR \u00bb }; #endif ''' } ... and integrate your new functionality in your \"doGenerate\" method: // integrate the new generator for ( e : resource . allContents . filter ( Entity ). toIterable ) { fsa . generateFile ( e . name + '.h' , generateCppCode ( e )) } Optional Step 4: Create a command line version of your \"compiler\" See xtext_deploy_command_line.md .","title":"Code Generation (with Xtend)"},{"location":"xtext_code_generation_xtend/#code-generation-with-xtend","text":"Xtend is highly optimized to be used for code generation. It has a optimized template engine (e.g., with automatic indentation support) and is fully integrated in the Eclipse IDE (auto completion for model data). Here we highlight some information when walking through (Xtext 15 Minutes Tutorial, Extended) , section \"Writing a Code Generator With Xtend\".","title":"Code Generation (with Xtend)"},{"location":"xtext_code_generation_xtend/#goal-of-this-section","text":"You learn how to generate artifacts in form of text files (e.g. source code). You learn how to format the output and how to access model data. After some basic steps you may have a look at xtext_xtend.md to learn more about the language xtend employed for the artifact generator. Finally, you see how you can generate a C++-file based on the model. You will see how you can start from an example code and iteratively replace concrete code with model data.","title":"Goal of this section"},{"location":"xtext_code_generation_xtend/#step-1-walk-through","text":"When reading (Xtext 15 Minutes Tutorial, Extended) , start with the first section \"Writing a Code Generator With Xtend\" (until \"Unit Testing the Language\"): Locate the file where the artifact generator is implemented (DomainmodelGenerator.xtend). \" doGenerate \" is the method called when generating artifacts from a model. Ignore the \"IQualifiedNameProvider\": You can just use \"obj.name\" in your example (instead of obj.fullyQualifiedName) for the moment. Xtend allows to use templates (indicated by multiline strings with three single quotes): Inside this templates you can place text which is directly inserted in the output. Special commands like \"IF\" or \"FOR\" can be used if placed between \"\u00ab\" and \"\u00bb\" (\"\u00ab\" and \"\u00bb\" can be entered using CTRL-< and CTRL-> within eclipse). It is also possible to insert local variable values (typically model data, e.g. '''the name of the entity is \u00abentity_var.name\u00bb'''). Tabs are inserted in an intelligent way, such that indentation associated with generator logic (e.g., after an \"\u00abIF\u00bb\") are not inserted into the output (such indentation is visually highlighted in the editor). Optional model elements which are represented as a class are null, when not used. Caution: Other elements, such as enums, INT, and STRING have default values. The example also shows that a modularization is possible (see how code for \"Features\" is inserted). Many aspects may look scary at first sight, but are extremely valuable for the given task of textual artifact generation: See xtext_xtend.md . Note: This following example also illustrates how to get the root of the model (val model=...). This object can be passed to a function generating some text from it. val model = resource . contents . get ( 0 ) as Domainmodel It also shows how to cast an object: \u201eobj as Type\u201c.","title":"Step 1: Walk through"},{"location":"xtext_code_generation_xtend/#step-2-question","text":"What is the following code doing? See xtext_xtend.md . override void doGenerate ( Resource resource , IFileSystemAccess2 fsa , IGeneratorContext context ) { fsa . generateFile ( 'greetings.txt' , 'People to greet: ' + resource . allContents . filter ( Entity ) . map [ name ] . join ( ', ' )) }","title":"Step 2: Question"},{"location":"xtext_code_generation_xtend/#step-3-next-step-extended-example","text":"Try to generate a C-code snippet: #ifndef __MYSTRUCT_H_ #define __MYSTRUCT_H_ #include <cstdint> struct MyStruct { float attribute1 ; int32_t attribute2 ; }; #endif When starting a new generator snippet, it can help to copy-paste the code to be generate as an example into your code: def generateCppCode ( Entity e ) { ''' #ifndef __MYSTRUCT_H_ #define __MYSTRUCT_H_ #include <cstdint> struct MyStruct { float attribute1; int32_t attribute2; }; #endif ''' } Then start replacing your example code with model information: def generateCppCode ( Entity e ) { ''' #ifndef __MYSTRUCT_H_ // TODO #define __MYSTRUCT_H_ // TODO #include <cstdint> struct \u00ab e . name \u00bb { \u00ab FOR f : e . features \u00bb TODO \u00ab f . name \u00bb; \u00ab ENDFOR \u00bb }; #endif ''' } ... and integrate your new functionality in your \"doGenerate\" method: // integrate the new generator for ( e : resource . allContents . filter ( Entity ). toIterable ) { fsa . generateFile ( e . name + '.h' , generateCppCode ( e )) }","title":"Step 3: Next step: Extended example"},{"location":"xtext_code_generation_xtend/#optional-step-4-create-a-command-line-version-of-your-compiler","text":"See xtext_deploy_command_line.md .","title":"Optional Step 4: Create a command line version of your \"compiler\""},{"location":"xtext_deploy_command_line/","text":"Xtext: deploy a command line version of the code generator Generate a command line version of the code generator Add the following entries to your mwe2 file (located side-by-side to your grammar; see e.g. (Bettini, 2016) ): ... language = StandardLanguage { ... generator = { generateJavaMain = true } ... } ... When running the mwe2 script (compiling your grammar; see Compile and Run the Project ), a Main.java file is created in the generator namespace side-by-side to your grammar. Optional: Modify Main.java The Main-class expects a model file to be processed: parsed, validated and generated code from the model. You can manually set the destination path ( change \"src-gen\" to something else). There is no workspace for the model files; you must modify the Main.java file in order to manually add other model files (e.g. from some sub folder or specified via the command line). E.g.: protected void runGenerator ( String main_model_filename , String [] all_other_filenames ) { // Load the resource ResourceSet set = resourceSetProvider . get (); Resource resource = set . getResource ( URI . createFileURI ( main_model_filename ), true ); List < Resource > all_resources = new ArrayList < Resource >(); all_resources . add ( resource ); // Load all other required resources for ( String m : all_other_filenames ) { if (! m . equals ( main_model_filename )) { Resource other = set . getResource ( URI . createFileURI ( m ), true ); all_resources . add ( other ); } } // Validate all resources for ( Resource r : all_resources ) { List < Issue > list = validator . validate ( r , CheckMode . ALL , CancelIndicator . NullImpl ); if (! list . isEmpty ()) { for ( Issue issue : list ) { System . err . println ( issue ); } return ; } } // Configure and start the generator fileAccess . setOutputPath ( \"src-gen/\" ); GeneratorContext context = new GeneratorContext (); context . setCancelIndicator ( CancelIndicator . NullImpl ); generator . generate ( resource , fileAccess , context ); System . out . println ( \"Code generation finished.\" ); } Manually create a runnable JAR file with the command line compiler In eclipse you can \" Export \" your generator as \" Runnable JAR \": Create a Run Configuration by right-clicking on your Main.java and select \"Run as\" / \"Java Application\". Then right-click on the project containing the Main.java file and select \"Export\", \"Runnable JAR file\". Select \"Main\" in the \"Launch configuration\". Select \"Package required libraries into generated JAR file\". Specify your destination JAR file name and click \"Finish\". Create the command line compiler with gradle See https://gitlab.com/Tim-S/xtext-dsl-headless-example for a very nice and compact description: you will learn how to deploy a command line version of the \"Hello World\" grammar using a few lines of code. Create the command line compiler with maven (work in progress) Close eclipse Clone https://github.com/basilfx/xtext-standalone-maven-build into some temporary directory (there is a good description there what to do) Copy the ...standalone-folder into your ...parent folder (side-by-side to your other projects) Rename the folder to match your project name (e.g. \"org.xtext.example.mydsl.standalone\" to \"org.example.domainmodel.standalone\") Rename (find/replace) the project name (replace \"org.xtext.example.mydsl\" with \"org.example.domainmodel\") in all files in the copied folder. Add the new folder/module to the modules list in your master pom.xml file (section \"modules\"). try \"mvn package\" in your master directory and check if the target in the new standalone module is created. The generated JAR file can then be tested as follows (assuming some model files are available): java -jar org.example.domainmodel.standalone/target/org.example.domainmodel.standalone-1.0.0-SNAPSHOT.jar *.dmodel Note: * no need to add (import) the standalone project into the eclipse workspace. * You can use the standalone code generator as \"compiler\" in a Makefile (like gcc). It will perform a model syntax check, a model validation and a code generation.","title":"Deploy a command line version"},{"location":"xtext_deploy_command_line/#xtext-deploy-a-command-line-version-of-the-code-generator","text":"","title":"Xtext: deploy a command line version of the code generator"},{"location":"xtext_deploy_command_line/#generate-a-command-line-version-of-the-code-generator","text":"Add the following entries to your mwe2 file (located side-by-side to your grammar; see e.g. (Bettini, 2016) ): ... language = StandardLanguage { ... generator = { generateJavaMain = true } ... } ... When running the mwe2 script (compiling your grammar; see Compile and Run the Project ), a Main.java file is created in the generator namespace side-by-side to your grammar.","title":"Generate a command line version of the code generator"},{"location":"xtext_deploy_command_line/#optional-modify-mainjava","text":"The Main-class expects a model file to be processed: parsed, validated and generated code from the model. You can manually set the destination path ( change \"src-gen\" to something else). There is no workspace for the model files; you must modify the Main.java file in order to manually add other model files (e.g. from some sub folder or specified via the command line). E.g.: protected void runGenerator ( String main_model_filename , String [] all_other_filenames ) { // Load the resource ResourceSet set = resourceSetProvider . get (); Resource resource = set . getResource ( URI . createFileURI ( main_model_filename ), true ); List < Resource > all_resources = new ArrayList < Resource >(); all_resources . add ( resource ); // Load all other required resources for ( String m : all_other_filenames ) { if (! m . equals ( main_model_filename )) { Resource other = set . getResource ( URI . createFileURI ( m ), true ); all_resources . add ( other ); } } // Validate all resources for ( Resource r : all_resources ) { List < Issue > list = validator . validate ( r , CheckMode . ALL , CancelIndicator . NullImpl ); if (! list . isEmpty ()) { for ( Issue issue : list ) { System . err . println ( issue ); } return ; } } // Configure and start the generator fileAccess . setOutputPath ( \"src-gen/\" ); GeneratorContext context = new GeneratorContext (); context . setCancelIndicator ( CancelIndicator . NullImpl ); generator . generate ( resource , fileAccess , context ); System . out . println ( \"Code generation finished.\" ); }","title":"Optional: Modify Main.java"},{"location":"xtext_deploy_command_line/#manually-create-a-runnable-jar-file-with-the-command-line-compiler","text":"In eclipse you can \" Export \" your generator as \" Runnable JAR \": Create a Run Configuration by right-clicking on your Main.java and select \"Run as\" / \"Java Application\". Then right-click on the project containing the Main.java file and select \"Export\", \"Runnable JAR file\". Select \"Main\" in the \"Launch configuration\". Select \"Package required libraries into generated JAR file\". Specify your destination JAR file name and click \"Finish\".","title":"Manually create a runnable JAR file with the command line compiler"},{"location":"xtext_deploy_command_line/#create-the-command-line-compiler-with-gradle","text":"See https://gitlab.com/Tim-S/xtext-dsl-headless-example for a very nice and compact description: you will learn how to deploy a command line version of the \"Hello World\" grammar using a few lines of code.","title":"Create the command line compiler with gradle"},{"location":"xtext_deploy_command_line/#create-the-command-line-compiler-with-maven","text":"(work in progress) Close eclipse Clone https://github.com/basilfx/xtext-standalone-maven-build into some temporary directory (there is a good description there what to do) Copy the ...standalone-folder into your ...parent folder (side-by-side to your other projects) Rename the folder to match your project name (e.g. \"org.xtext.example.mydsl.standalone\" to \"org.example.domainmodel.standalone\") Rename (find/replace) the project name (replace \"org.xtext.example.mydsl\" with \"org.example.domainmodel\") in all files in the copied folder. Add the new folder/module to the modules list in your master pom.xml file (section \"modules\"). try \"mvn package\" in your master directory and check if the target in the new standalone module is created. The generated JAR file can then be tested as follows (assuming some model files are available): java -jar org.example.domainmodel.standalone/target/org.example.domainmodel.standalone-1.0.0-SNAPSHOT.jar *.dmodel Note: * no need to add (import) the standalone project into the eclipse workspace. * You can use the standalone code generator as \"compiler\" in a Makefile (like gcc). It will perform a model syntax check, a model validation and a code generation.","title":"Create the command line compiler with maven"},{"location":"xtext_deploy_plugin/","text":"Deploy your DSL as eclipse plugin Manual way to export and install a plugin Within eclipse Export your language as \"Deployable features\". Select the \"*.feature\" project of your language. Select an archive file name to export your plugin In the \"Options\" tab: \"Browse\" for \"Categorize repository\" and select the \"*.repository\" project of your language. Click \"finish\". Then, you can install the plugin from the exported archive in an eclipse installation (You can, e.g., copy your eclipse folder, start the copy, install your plugin and give the eclipse to another person). Installation is done using the menu: \"Help/Install New Software\". Notes: (1) When installing the plugin, it may be useful to disable \"Contact all update sites...\" (this caused problems in some examples). (2) You are also prompted, that the new plugin is not signed (you must accept this in order to continue). Create a product (work in progress)","title":"Deploy an eclispe plugin"},{"location":"xtext_deploy_plugin/#deploy-your-dsl-as-eclipse-plugin","text":"","title":"Deploy your DSL as eclipse plugin"},{"location":"xtext_deploy_plugin/#manual-way-to-export-and-install-a-plugin","text":"Within eclipse Export your language as \"Deployable features\". Select the \"*.feature\" project of your language. Select an archive file name to export your plugin In the \"Options\" tab: \"Browse\" for \"Categorize repository\" and select the \"*.repository\" project of your language. Click \"finish\". Then, you can install the plugin from the exported archive in an eclipse installation (You can, e.g., copy your eclipse folder, start the copy, install your plugin and give the eclipse to another person). Installation is done using the menu: \"Help/Install New Software\". Notes: (1) When installing the plugin, it may be useful to disable \"Contact all update sites...\" (this caused problems in some examples). (2) You are also prompted, that the new plugin is not signed (you must accept this in order to continue).","title":"Manual way to export and install a plugin"},{"location":"xtext_deploy_plugin/#create-a-product","text":"(work in progress)","title":"Create a product"},{"location":"xtext_eclipse/","text":"Xtext and Eclipse Xtext is integrated in Eclispe. To run this tutorial (using Xtext) you need to install Eclipse with the appropriate plugins. Note: The parser \"Antlr\" is not distributed with eclipse. You need to install it manually (itemis update site) , else it will be downloaded for every Xtext project you create. Download and install Download the package \"Eclipse Modeling\" . Unpack the archive to make eclipse available. root@xtext:~/Download# ls eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz root@xtext:~/Download# tar xzf eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz root@xtext:~/Download# mv eclipse /opt/ root@xtext:~/Download# /opt/eclipse/eclipse & To complete the installation you need \"Install New Software\" from the \"Help\" menu entry. Enter the URL of the itemis update site (see above) in the field \"work with\" and press enter. Then select \"Xtext\" and \"Xtext Antlr\" and install the selected software.","title":"Eclipse"},{"location":"xtext_eclipse/#xtext-and-eclipse","text":"Xtext is integrated in Eclispe. To run this tutorial (using Xtext) you need to install Eclipse with the appropriate plugins. Note: The parser \"Antlr\" is not distributed with eclipse. You need to install it manually (itemis update site) , else it will be downloaded for every Xtext project you create.","title":"Xtext and Eclipse"},{"location":"xtext_eclipse/#download-and-install","text":"Download the package \"Eclipse Modeling\" . Unpack the archive to make eclipse available. root@xtext:~/Download# ls eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz root@xtext:~/Download# tar xzf eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz root@xtext:~/Download# mv eclipse /opt/ root@xtext:~/Download# /opt/eclipse/eclipse & To complete the installation you need \"Install New Software\" from the \"Help\" menu entry. Enter the URL of the itemis update site (see above) in the field \"work with\" and press enter. Then select \"Xtext\" and \"Xtext Antlr\" and install the selected software.","title":"Download and install"},{"location":"xtext_howtos/","text":"Xtext HOWTOs Here, we collect short snippets to solve common problems. Define a named object Use the special attribute \"name\" in combination with default scope providers. ... MyObj : 'myobj' name = ID Define an optional attribute Use \"(...)?\". Note: * Some types, like INT or enums have default values (like 0 for INTs) and, thus, an unset value cannot be distinguished from, e.g., the value 0. * Using helper objects (like \"Other\" in the example below) helps to detect unset optional values, since the object is \"null\", if not set. ... MyObj : 'myobj' name = ID ( option_int = INT )? ( option_obj = Other )? ; Other : 'other' val = INT ; Define a boolean flag based on the presence of a keyword See Xtext documentation: ... MyObj : 'myobj' name = ID ( option_flag ?= 'flag_keyword' )? Define an enum See Xtext docu. Note: The first enum value is the default value. ... MyObj : 'myobj' name = ID '=' value = MyEnum ; enum MyEnum : val1 = 'VAL1' | val2 = 'VAL2' | val3 = 'VAL3' ; Force the creation of an object when no attributes are defined Object without attributes are not instantiated as objects in the model representation. This can also happen, when all attributes are optional and not set in a concrete model (in this case you get a warning in your grammar). Use \"{Rule-name}\" to force instantiation. MyObj : { MyObj } 'myobj' ( value = MyVal )? ; MyVal : text = STING ; Define an attribute containing a list ... Model : things += Thing * ; Thing : 'thing' name = ID ; Add one element to a list ... Model : things += Thing ; Thing : 'thing' name = ID ; Define a comma separated list ... Model : things += Thing ( ',' things += Thing )* ; Thing : 'thing' name = ID ; Define an element to represent either a signed int or a float Example grammar snippet defining a 'myobj' containing a name and either a float or an integer value: import \"http : //www.eclipse.org/emf/2002/Ecore\" as ecore ... MyObj : 'myobj' name = ID '=' ( value = MyVal )? ; MyVal : MyInt | MyFloat ; MyInt : ivalue = MYINT_T ; MyFloat : fvalue = MYFLOAT_T ; terminal MYINT_T returns ecore :: EInt : '-' ? INT ; terminal MYFLOAT_T returns ecore :: EFloat : '-' ? INT '.' INT ; With the test illustrating the types (int/float): @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper testHelper ; ... @Test def void testFloatInt () { val result = ''' myobj pi=3.1415 myobj N=4 ''' . parse result . assertNotNull result . assertNoErrors assertTrue ( result . objs . head . value instanceof MyFloat ) val f = ( result . objs . head . value as MyFloat ). fvalue assertEquals ( 3.1415 , f , 1 e - 4 ) assertTrue ( result . objs . last . value instanceof MyInt ) val i = ( result . objs . last . value as MyInt ). ivalue assertEquals ( 4 , i ) } Allow keywords as name of elements Problem : keywords (like 'myobj' or 'ref' in the example below) are not classified as \"ID\" by the lexer. Thus, they cannot be used as ID (the default lexer token for references). ... MyObj : 'myobj' name = ID Ref : 'ref' [ MyObj ]; // same as [MyObj|ID] Solution : see https://blogs.itemis.com/en/xtext-hint-identifiers-conflicting-with-keywords for more details. Define a VALID_ID, including the desired keywords to be allowed as name: ... MyObj : 'myobj' name = ID Ref : 'ref' [ MyObj|VALID_ID ]; VALID_ID : ID | 'ref' | 'myobj' Define a list of objects with the same base type Example: struct Simple { scalar x array y[10] scalar z } With grammar: ... Struct : 'struct' name = ID '{' attrs += Attribute + '}' ; Attribute : ScalarAttribute | ArrayAttribute ; ScalarAttribute : 'scalar' name = ID ; ArrayAttribute : 'array' name = ID '[' dim = INT ']' ; Allow to model a mix of objects of unrelated type Example (same as in last example): struct Simple { scalar x array y[10] scalar z } With grammar: ... Struct : 'struct' name = ID '{' ( s += ScalarAttribute | a += ArrayAttribute )* '}' ; ScalarAttribute : 'scalar' name = ID ; ArrayAttribute : 'array' name = ID '[' dim = INT ']' ; Define multiline string attributes You can use the \"->\" feature for terminals. You need to strip the leading and trailing '\"\"\"' when accessing the multiline string (e.g., with a xtend extension method). Grammar snippet: ... MultlineInfo : 'info' text = MLTEXT ; terminal MLTEXT : '\"\"\"' -> '\"\"\"' ; Xtend code snippet and test: static def getMltext ( MultlineInfo info ) { info . text . replaceAll ( '^\"\"\"' , '' ). replaceAll ( '\"\"\"$' , '' ); } @Test def void testMlInfo () { val result = ''' info \"\"\"Hello World\"\"\" info \"\"\"Hello Multiline World\"\"\" ''' . parse result . assertNotNull result . assertNoErrors assertEquals ( '\"\"\"Hello World\"\"\"' , result . infos . head . text ) assertEquals ( \"Hello World\" , result . infos . head . mltext ) assertEquals ( \"Hello Multiline\\nWorld\" , result . infos . last . mltext ) } Filter a list based on a type resource . allContents . filter ( Entity ) Filter a list based on an attribute value resource . allContents . filter ( Entity ). filter [ name = \"Tom\" ] Transform a list resource . allContents . filter ( Entity ). map [ e | 'the name is ' + e . name ] Concatenate two lists // list1 and list2 are of type java.util.List<...> ( list1 + list2 ). toList","title":"Xtext HOWTOs"},{"location":"xtext_howtos/#xtext-howtos","text":"Here, we collect short snippets to solve common problems.","title":"Xtext HOWTOs"},{"location":"xtext_howtos/#define-a-named-object","text":"Use the special attribute \"name\" in combination with default scope providers. ... MyObj : 'myobj' name = ID","title":"Define a named object"},{"location":"xtext_howtos/#define-an-optional-attribute","text":"Use \"(...)?\". Note: * Some types, like INT or enums have default values (like 0 for INTs) and, thus, an unset value cannot be distinguished from, e.g., the value 0. * Using helper objects (like \"Other\" in the example below) helps to detect unset optional values, since the object is \"null\", if not set. ... MyObj : 'myobj' name = ID ( option_int = INT )? ( option_obj = Other )? ; Other : 'other' val = INT ;","title":"Define an optional attribute"},{"location":"xtext_howtos/#define-a-boolean-flag-based-on-the-presence-of-a-keyword","text":"See Xtext documentation: ... MyObj : 'myobj' name = ID ( option_flag ?= 'flag_keyword' )?","title":"Define a boolean flag based on the presence of a keyword"},{"location":"xtext_howtos/#define-an-enum","text":"See Xtext docu. Note: The first enum value is the default value. ... MyObj : 'myobj' name = ID '=' value = MyEnum ; enum MyEnum : val1 = 'VAL1' | val2 = 'VAL2' | val3 = 'VAL3' ;","title":"Define an enum"},{"location":"xtext_howtos/#force-the-creation-of-an-object-when-no-attributes-are-defined","text":"Object without attributes are not instantiated as objects in the model representation. This can also happen, when all attributes are optional and not set in a concrete model (in this case you get a warning in your grammar). Use \"{Rule-name}\" to force instantiation. MyObj : { MyObj } 'myobj' ( value = MyVal )? ; MyVal : text = STING ;","title":"Force the creation of an object when no attributes are defined"},{"location":"xtext_howtos/#define-an-attribute-containing-a-list","text":"... Model : things += Thing * ; Thing : 'thing' name = ID ;","title":"Define an attribute containing a list"},{"location":"xtext_howtos/#add-one-element-to-a-list","text":"... Model : things += Thing ; Thing : 'thing' name = ID ;","title":"Add one element to a list"},{"location":"xtext_howtos/#define-a-comma-separated-list","text":"... Model : things += Thing ( ',' things += Thing )* ; Thing : 'thing' name = ID ;","title":"Define a comma separated list"},{"location":"xtext_howtos/#define-an-element-to-represent-either-a-signed-int-or-a-float","text":"Example grammar snippet defining a 'myobj' containing a name and either a float or an integer value: import \"http : //www.eclipse.org/emf/2002/Ecore\" as ecore ... MyObj : 'myobj' name = ID '=' ( value = MyVal )? ; MyVal : MyInt | MyFloat ; MyInt : ivalue = MYINT_T ; MyFloat : fvalue = MYFLOAT_T ; terminal MYINT_T returns ecore :: EInt : '-' ? INT ; terminal MYFLOAT_T returns ecore :: EFloat : '-' ? INT '.' INT ; With the test illustrating the types (int/float): @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper testHelper ; ... @Test def void testFloatInt () { val result = ''' myobj pi=3.1415 myobj N=4 ''' . parse result . assertNotNull result . assertNoErrors assertTrue ( result . objs . head . value instanceof MyFloat ) val f = ( result . objs . head . value as MyFloat ). fvalue assertEquals ( 3.1415 , f , 1 e - 4 ) assertTrue ( result . objs . last . value instanceof MyInt ) val i = ( result . objs . last . value as MyInt ). ivalue assertEquals ( 4 , i ) }","title":"Define an element to represent either a signed int or a float"},{"location":"xtext_howtos/#allow-keywords-as-name-of-elements","text":"Problem : keywords (like 'myobj' or 'ref' in the example below) are not classified as \"ID\" by the lexer. Thus, they cannot be used as ID (the default lexer token for references). ... MyObj : 'myobj' name = ID Ref : 'ref' [ MyObj ]; // same as [MyObj|ID] Solution : see https://blogs.itemis.com/en/xtext-hint-identifiers-conflicting-with-keywords for more details. Define a VALID_ID, including the desired keywords to be allowed as name: ... MyObj : 'myobj' name = ID Ref : 'ref' [ MyObj|VALID_ID ]; VALID_ID : ID | 'ref' | 'myobj'","title":"Allow keywords as name of elements"},{"location":"xtext_howtos/#define-a-list-of-objects-with-the-same-base-type","text":"Example: struct Simple { scalar x array y[10] scalar z } With grammar: ... Struct : 'struct' name = ID '{' attrs += Attribute + '}' ; Attribute : ScalarAttribute | ArrayAttribute ; ScalarAttribute : 'scalar' name = ID ; ArrayAttribute : 'array' name = ID '[' dim = INT ']' ;","title":"Define a list of objects with the same base type"},{"location":"xtext_howtos/#allow-to-model-a-mix-of-objects-of-unrelated-type","text":"Example (same as in last example): struct Simple { scalar x array y[10] scalar z } With grammar: ... Struct : 'struct' name = ID '{' ( s += ScalarAttribute | a += ArrayAttribute )* '}' ; ScalarAttribute : 'scalar' name = ID ; ArrayAttribute : 'array' name = ID '[' dim = INT ']' ;","title":"Allow to model a mix of objects of unrelated type"},{"location":"xtext_howtos/#define-multiline-string-attributes","text":"You can use the \"->\" feature for terminals. You need to strip the leading and trailing '\"\"\"' when accessing the multiline string (e.g., with a xtend extension method). Grammar snippet: ... MultlineInfo : 'info' text = MLTEXT ; terminal MLTEXT : '\"\"\"' -> '\"\"\"' ; Xtend code snippet and test: static def getMltext ( MultlineInfo info ) { info . text . replaceAll ( '^\"\"\"' , '' ). replaceAll ( '\"\"\"$' , '' ); } @Test def void testMlInfo () { val result = ''' info \"\"\"Hello World\"\"\" info \"\"\"Hello Multiline World\"\"\" ''' . parse result . assertNotNull result . assertNoErrors assertEquals ( '\"\"\"Hello World\"\"\"' , result . infos . head . text ) assertEquals ( \"Hello World\" , result . infos . head . mltext ) assertEquals ( \"Hello Multiline\\nWorld\" , result . infos . last . mltext ) }","title":"Define multiline string attributes"},{"location":"xtext_howtos/#filter-a-list-based-on-a-type","text":"resource . allContents . filter ( Entity )","title":"Filter a list based on a type"},{"location":"xtext_howtos/#filter-a-list-based-on-an-attribute-value","text":"resource . allContents . filter ( Entity ). filter [ name = \"Tom\" ]","title":"Filter a list based on an attribute value"},{"location":"xtext_howtos/#transform-a-list","text":"resource . allContents . filter ( Entity ). map [ e | 'the name is ' + e . name ]","title":"Transform a list"},{"location":"xtext_howtos/#concatenate-two-lists","text":"// list1 and list2 are of type java.util.List<...> ( list1 + list2 ). toList","title":"Concatenate two lists"},{"location":"xtext_model_validation/","text":"Model Validation A model can be validated according certain validation rules. These rules have to be define by the meta modeller in the meta model. Error and warning messages can be reported and attached to model elements or text location. These messages are displayed in the Eclipse model text editor. More Information, see (Mooij et al, 2017a) . (Rentz-Reichert, 2017) suggested to put as little as possible semantics into the grammar (e.g. \"+\" instead of \"*\") and to add this semantics to the validation code. This often allows to generate more meaningful domain errors. A good introduction can be found here: (Xtext 15 Minutes Tutorial, Extended) , in the section \"Creating Custom Validation Rules\". Validation Example Open the *Validator.xtend\" file (automatically generated for a new project), e.g., \"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\". Activate the commented code and modify it: package kurs . xtext . dataflow . validation import org.eclipse.xtext.validation.Check import kurs.xtext.dataflow.dataFlowDsl.KComponent import kurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage class DataFlowDslValidator extends AbstractDataFlowDslValidator { public static val INVALID_NAME = 'invalidName' @Check def checkGreetingStartsWithCapital ( Entity obj ) { if (! Character . isUpperCase ( obj . name . charAt ( 0 ))) { warning ( 'Name should start with a capital' , DomainmodelPackage . Literals . TYPE__NAME , INVALID_NAME ) } } } Try your validator for your language in the Eclipse Runtime model editor. Notes: A validation rule is marked as such with the annotation \"@Check\". The argument is a model element of the type to be checked. The rule is checked during typing in the editor (@Check allows to control if a rule is checked during typing, when saving, or upon explicit request (see: org.eclipse.xtext.validation.CheckType; press \"F3\" when having the cursor on @Check) The rule above checks elements of type \"Entity\". Errors/warning, if present, are attached to this model element. A rule can generate \"errors\", \"warnings\" und \"infos\". The ID (in our case \"INVALID_NAME\") allows a rule to be identified later, e.g., when implementing HotFixes for specific validation violations. Why did we use \"TYPE_NAME\" instead of ENTITY_NAME? (Hint: ENTITY_NAME does not exist; How are Type and Entity related to each other?)","title":"Model Validation"},{"location":"xtext_model_validation/#model-validation","text":"A model can be validated according certain validation rules. These rules have to be define by the meta modeller in the meta model. Error and warning messages can be reported and attached to model elements or text location. These messages are displayed in the Eclipse model text editor. More Information, see (Mooij et al, 2017a) . (Rentz-Reichert, 2017) suggested to put as little as possible semantics into the grammar (e.g. \"+\" instead of \"*\") and to add this semantics to the validation code. This often allows to generate more meaningful domain errors. A good introduction can be found here: (Xtext 15 Minutes Tutorial, Extended) , in the section \"Creating Custom Validation Rules\".","title":"Model "},{"location":"xtext_model_validation/#validation-example","text":"Open the *Validator.xtend\" file (automatically generated for a new project), e.g., \"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\". Activate the commented code and modify it: package kurs . xtext . dataflow . validation import org.eclipse.xtext.validation.Check import kurs.xtext.dataflow.dataFlowDsl.KComponent import kurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage class DataFlowDslValidator extends AbstractDataFlowDslValidator { public static val INVALID_NAME = 'invalidName' @Check def checkGreetingStartsWithCapital ( Entity obj ) { if (! Character . isUpperCase ( obj . name . charAt ( 0 ))) { warning ( 'Name should start with a capital' , DomainmodelPackage . Literals . TYPE__NAME , INVALID_NAME ) } } } Try your validator for your language in the Eclipse Runtime model editor. Notes: A validation rule is marked as such with the annotation \"@Check\". The argument is a model element of the type to be checked. The rule is checked during typing in the editor (@Check allows to control if a rule is checked during typing, when saving, or upon explicit request (see: org.eclipse.xtext.validation.CheckType; press \"F3\" when having the cursor on @Check) The rule above checks elements of type \"Entity\". Errors/warning, if present, are attached to this model element. A rule can generate \"errors\", \"warnings\" und \"infos\". The ID (in our case \"INVALID_NAME\") allows a rule to be identified later, e.g., when implementing HotFixes for specific validation violations. Why did we use \"TYPE_NAME\" instead of ENTITY_NAME? (Hint: ENTITY_NAME does not exist; How are Type and Entity related to each other?)","title":"Validation Example"},{"location":"xtext_modularization/","text":"Xtext: Model Modularization In this section we present possibilities to modularize your model data across multiple files, in order to reuse model data and to divide model data into smaller parts. Modularization within the same Meta Model This topic is covered in xtext_scoping.md . Referencing Model Elements form other Meta Models When you have an existing metamodel (an Xtext language, e.g., \"org.xtext.example.mydsl\"), you can create another language referencing this existing language. In the new language (in eclipse a new project, created side-by-side to the existing language, e.g., \"org.xtext.example.mydsl1.MyDsl1\"; details see (Mooij et al, 2017b) ): Add plugin dependency in MANIFEST.MF in your new language project (e.g., \"org.xtext.example.mydsl1\") open org.xtext.example.mydsl1/META_INF/MANIFEST.MF click on \"Dependencies\" \"Add...\" in \"Required Plug-Ins\" select the existing language and the ui package (e.g. \"org.xtext.example.mydsl\" and \"org.xtext.example.mydsl.ui\") save MANIFEST.MF (CTRL-S) Add plugin dependency in MANIFEST.MF of your new \"ui\" project (e.g., \"org.xtext.example.mydsl1.ui\"). same as for the language project. In the mwe2.file (side-by-side to the grammar of your new language) add to section \"language\" (after \"name\"; you can check the path and the file name in your existing language) referencedResource = \"platform:/resource/org.xtext.example.mydsl/model/generated/MyDsl.genmodel\" In your new grammar, import the existing language (check the grammar of the existing language for the URL). You can reference elements from your existing language as shown below: import \"http://www.xtext.org/example/mydsl/MyDsl\" as existingDsl ... Greeting : 'Hello' '-->' ref = [ existingDsl :: Greeting ]; For the standalone setup in Main.java (command line version), you need to run the following code before Injector injector = new MyDslStandaloneSetup().createInjectorAndDoEMFRegistration(); : org.xtext.example.mydsl.MyDslStandaloneSetup stse_ref = new org.xtext.example.mydsl.MyDslStandaloneSetup(); Injector i_ref = stse_ref.createInjector(); stse_ref.register(i_ref); Note: Do not forget to have the \"Build Automatically\" enabled in the eclipse menu \"Project\".","title":"Modularization"},{"location":"xtext_modularization/#xtext-model-modularization","text":"In this section we present possibilities to modularize your model data across multiple files, in order to reuse model data and to divide model data into smaller parts.","title":"Xtext: Model Modularization"},{"location":"xtext_modularization/#modularization-within-the-same-meta-model","text":"This topic is covered in xtext_scoping.md .","title":"Modularization within the same Meta Model"},{"location":"xtext_modularization/#referencing-model-elements-form-other-meta-models","text":"When you have an existing metamodel (an Xtext language, e.g., \"org.xtext.example.mydsl\"), you can create another language referencing this existing language. In the new language (in eclipse a new project, created side-by-side to the existing language, e.g., \"org.xtext.example.mydsl1.MyDsl1\"; details see (Mooij et al, 2017b) ): Add plugin dependency in MANIFEST.MF in your new language project (e.g., \"org.xtext.example.mydsl1\") open org.xtext.example.mydsl1/META_INF/MANIFEST.MF click on \"Dependencies\" \"Add...\" in \"Required Plug-Ins\" select the existing language and the ui package (e.g. \"org.xtext.example.mydsl\" and \"org.xtext.example.mydsl.ui\") save MANIFEST.MF (CTRL-S) Add plugin dependency in MANIFEST.MF of your new \"ui\" project (e.g., \"org.xtext.example.mydsl1.ui\"). same as for the language project. In the mwe2.file (side-by-side to the grammar of your new language) add to section \"language\" (after \"name\"; you can check the path and the file name in your existing language) referencedResource = \"platform:/resource/org.xtext.example.mydsl/model/generated/MyDsl.genmodel\" In your new grammar, import the existing language (check the grammar of the existing language for the URL). You can reference elements from your existing language as shown below: import \"http://www.xtext.org/example/mydsl/MyDsl\" as existingDsl ... Greeting : 'Hello' '-->' ref = [ existingDsl :: Greeting ]; For the standalone setup in Main.java (command line version), you need to run the following code before Injector injector = new MyDslStandaloneSetup().createInjectorAndDoEMFRegistration(); : org.xtext.example.mydsl.MyDslStandaloneSetup stse_ref = new org.xtext.example.mydsl.MyDslStandaloneSetup(); Injector i_ref = stse_ref.createInjector(); stse_ref.register(i_ref); Note: Do not forget to have the \"Build Automatically\" enabled in the eclipse menu \"Project\".","title":"Referencing Model Elements form other Meta Models"},{"location":"xtext_project_setup/","text":"Xtext Project Setup Goal In this section you will learn How to create a new XText Project. How to run you toolchain (editor and parser). What Project structures are created. Run a unittest testing the parser. Optional: How to start a build of your toolchain with maven at the command line Get more help: (Xtext Help) . Step 1: Create a new Xtext Project Follow section \"Create A New Xtext Project\" in (Xtext 15 Minutes Tutorial) . In addition to the information from the tutorial we suggest the following details for the other examples discussed on this site: The result are a set of projects: we are mainly interested in the first project, which contains the grammar. Step 2: Exploring the new domain model language The example grammar (automatically created after project initialization) defines a \"Model\" consisting of \"Greetings\" is shown in the following. A \"Model\" contains \"Greetings\". Every \"Greeting\" consists of the Text 'Hello' and a name followed by '!' (details below). grammar org.example.domainmodel.Domainmodel with org.eclipse.xtext.common.Terminals generate domainmodel \"http : //www.example.org/domainmodel/Domainmodel\" Model : greetings += Greeting * ; Greeting : 'Hello' name = ID '!' ; Notes: \"+=\" denotes the owner relationship of one Model containing many Greetings ( composition ). \"name=ID\" defines an attribute \"name\" of the Rule \"Greeting\" (allowing to define model elements of the type \"Greeting\"; attributes of model elements ). The attribute name has a special meaning by default, to denote the identifier of the Rule ( identification of model elements ). ID is a terminal (like INT, STRING, etc.; see grammar, and click \"F3\" on \"org.eclipse.xtext.common.Terminals\" to see definition). \"name=ID\" means that the attribute \"name\" is parsed as \"ID\" (which in turn is - more or less - an alphanumerical word staring with no number) Note on version control When using git or svn make sure not to commit any generated code (e.g. everything under src-gen and xtend-gen). Use, e.g., a .gitignore file like the following: target src-gen xtend-gen .settings .metadata bin generated Step 3: Compile and Run the Project Compile and Run the Project: Without modifing the grammar (or anything else), follow the steps in section \"Generate Language Artifacts\" in (Xtext 15 Minutes Tutorial) . After this, you can use explore the editor and enter a model according to the example meta model grammar provided by the Xtext project setup. Now you can play with your new language (type CTRL-Space to get auto completion). Enter the following example: Hello Pierre! Hello Tim! Hello Markus! Step 5: Add Unittests In the test project you can add a unittests. Locate the single file in the src folder. This file contains a unittest. Uncomment the test code and run the test. Note: You need to generate the xtext artifact before (see above). You may extend the default test code by adding the following: @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper validationHelper The you can easily check that no errors occurred while parsing: package org . xtext . example . mydsl . tests ... @RunWith ( XtextRunner ) @InjectWith ( MyDslInjectorProvider ) class MyDslParsingTest { @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper validationHelper @Test def void loadModel () { val result = parseHelper . parse ( ''' Hello Xtext! ''' ) Assert . assertNotNull ( result ) result . assertNoErrors } } Optional step 5: Build meta model using maven When maven is selected as build tool, you can also use maven (instead of eclipse) to build your project on the command line: Go to the \"parent\" project and run \"mvn package\". Maven will download all required packages in \"~/.m2\" (locally) and then build your sub-projects. The output is located in the folder \"target\" of each sub-project. See also: (Maven) . Hint: When using the Xtext version shipped with the Photon eclipse version in September 2018, I got an error reported by maven which I solved by inserting a small snippet to correct a version (everything between <dependencies> and </dependencies>, see https://github.com/eclipse/xtext/issues/1231 . <plugin> <groupId> org.eclipse.xtend </groupId> <artifactId> xtend-maven-plugin </artifactId> <version> ${ xtextVersion } </version> <dependencies> <dependency> <groupId> org.eclipse.platform </groupId> <artifactId> org.eclipse.equinox.common </artifactId> <version> 3.10.0 </version> </dependency> </dependencies> ...","title":"Xtext Project Setup"},{"location":"xtext_project_setup/#xtext-project-setup","text":"","title":"Xtext Project Setup"},{"location":"xtext_project_setup/#goal","text":"In this section you will learn How to create a new XText Project. How to run you toolchain (editor and parser). What Project structures are created. Run a unittest testing the parser. Optional: How to start a build of your toolchain with maven at the command line Get more help: (Xtext Help) .","title":"Goal"},{"location":"xtext_project_setup/#step-1-create-a-new-xtext-project","text":"Follow section \"Create A New Xtext Project\" in (Xtext 15 Minutes Tutorial) . In addition to the information from the tutorial we suggest the following details for the other examples discussed on this site: The result are a set of projects: we are mainly interested in the first project, which contains the grammar.","title":"Step 1: Create a new Xtext Project"},{"location":"xtext_project_setup/#step-2-exploring-the-new-domain-model-language","text":"The example grammar (automatically created after project initialization) defines a \"Model\" consisting of \"Greetings\" is shown in the following. A \"Model\" contains \"Greetings\". Every \"Greeting\" consists of the Text 'Hello' and a name followed by '!' (details below). grammar org.example.domainmodel.Domainmodel with org.eclipse.xtext.common.Terminals generate domainmodel \"http : //www.example.org/domainmodel/Domainmodel\" Model : greetings += Greeting * ; Greeting : 'Hello' name = ID '!' ; Notes: \"+=\" denotes the owner relationship of one Model containing many Greetings ( composition ). \"name=ID\" defines an attribute \"name\" of the Rule \"Greeting\" (allowing to define model elements of the type \"Greeting\"; attributes of model elements ). The attribute name has a special meaning by default, to denote the identifier of the Rule ( identification of model elements ). ID is a terminal (like INT, STRING, etc.; see grammar, and click \"F3\" on \"org.eclipse.xtext.common.Terminals\" to see definition). \"name=ID\" means that the attribute \"name\" is parsed as \"ID\" (which in turn is - more or less - an alphanumerical word staring with no number)","title":"Step 2: Exploring the new domain model language"},{"location":"xtext_project_setup/#note-on-version-control","text":"When using git or svn make sure not to commit any generated code (e.g. everything under src-gen and xtend-gen). Use, e.g., a .gitignore file like the following: target src-gen xtend-gen .settings .metadata bin generated","title":"Note on version control"},{"location":"xtext_project_setup/#step-3-compile-and-run-the-project","text":"Compile and Run the Project: Without modifing the grammar (or anything else), follow the steps in section \"Generate Language Artifacts\" in (Xtext 15 Minutes Tutorial) . After this, you can use explore the editor and enter a model according to the example meta model grammar provided by the Xtext project setup. Now you can play with your new language (type CTRL-Space to get auto completion). Enter the following example: Hello Pierre! Hello Tim! Hello Markus!","title":"Step 3: Compile and Run the Project"},{"location":"xtext_project_setup/#step-5-add-unittests","text":"In the test project you can add a unittests. Locate the single file in the src folder. This file contains a unittest. Uncomment the test code and run the test. Note: You need to generate the xtext artifact before (see above). You may extend the default test code by adding the following: @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper validationHelper The you can easily check that no errors occurred while parsing: package org . xtext . example . mydsl . tests ... @RunWith ( XtextRunner ) @InjectWith ( MyDslInjectorProvider ) class MyDslParsingTest { @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper validationHelper @Test def void loadModel () { val result = parseHelper . parse ( ''' Hello Xtext! ''' ) Assert . assertNotNull ( result ) result . assertNoErrors } }","title":"Step 5: Add Unittests"},{"location":"xtext_project_setup/#optional-step-5-build-meta-model-using-maven","text":"When maven is selected as build tool, you can also use maven (instead of eclipse) to build your project on the command line: Go to the \"parent\" project and run \"mvn package\". Maven will download all required packages in \"~/.m2\" (locally) and then build your sub-projects. The output is located in the folder \"target\" of each sub-project. See also: (Maven) . Hint: When using the Xtext version shipped with the Photon eclipse version in September 2018, I got an error reported by maven which I solved by inserting a small snippet to correct a version (everything between <dependencies> and </dependencies>, see https://github.com/eclipse/xtext/issues/1231 . <plugin> <groupId> org.eclipse.xtend </groupId> <artifactId> xtend-maven-plugin </artifactId> <version> ${ xtextVersion } </version> <dependencies> <dependency> <groupId> org.eclipse.platform </groupId> <artifactId> org.eclipse.equinox.common </artifactId> <version> 3.10.0 </version> </dependency> </dependencies> ...","title":"Optional step 5: Build meta model using maven"},{"location":"xtext_scoping/","text":"Xtext Scoping In this section you will learn the following: What scoping means and where you need it. How to customize scoping for special lookups of local elements. How to select scope providers to handle models distributed across different files. Scoping: What is it and where do I need it? Scoping is always relevant, when a reference (e.g., \"Thing: ref=[OtherThing]\") is resolved after parsing the model text. Details see basics.md . Scoping: Global identification of elements When you identify an element by name (in order to reference it) you use the default scope provider of Xtext. It resembles the Java scope (based on packages separated by dots). Problem In order to make use of the full qualified name of an element the default format of references is not enough to formulate the name (because dots are not part of this default format): Model : packages += Pack * ; Pack : 'package' name = ID '{' ( defs += Def | calls += Call )* '}' ; Def : 'def' name = ID ; Call : 'call' ref = [ Def ]; // same as \"ref=[Def|ID]\" With this grammar the default format \"ID\" is used to reference A objects in B objects. The following will work because all elements are in the same hierarchical element (Package): package p1 { def a1 def a2 call a1 call a2 } The following will not work package p1 { def a1 } package p2 { def a2 call a1 // will not work (a1 is located in p1) call a2 } Solution Model : packages += Pack * ; Pack : 'package' name = ID '{' ( defs += Def | calls += Call )* '}' ; Def : 'def' name = ID ; Call : 'call' ref = [ Def|FQN ]; FQN hidden() : ID ( '.' ID )* ; Here we allow the format of the reference to be a dot-separated name. Note : The optional \"hidden()\" controls which tokens are ignored (hidden). Hidden tokens are, e.g., whitespaces and comments by default. With \"hidden()\" no such tokens are ignored, thus, not allowing, e.g., whitespaces between the dot separated parts of a name.* With this, the default scope provider allows models as in the following example: package p1 { def a1 } package p2 { def a2 call p1.a1 call a2 } Models distributed across multiple files When distributing the model across different file, you can control how model elements are allowed to reference other model elements in different model files. DefaultGlobalScopeProvider \"make everything visible\" The default scope provider allows referencing any model element in the available resources. In case of an eclipse project with model files, those resources consist of all model files in the current project. Thus, you can reference any model element without any import or include statement. For example, elements from p1.mydsl: package p1 { def a1 } may be referenced by elements in p2.mydsl: package p2 { call p1.a1 } Note: When creating a standalone compiler for your DSL, you do not have such things as a workspace. In this case, you can manually provide this information, as illustrated in xtext_deploy_command_line.md . ImportUriGlobalScopeProvider \"#include <other>\" You can easily change the visibility to provide a language with explicit import statements; see e.g. (Mooij et al, 2017b) . These steps sum up as follows for a simple default project: Add the \"ImportUriValidator\" in your mwe2-file (side-by-side to your grammar). ... validator = { // composedCheck = \"org.eclipse.xtext.validation.NamesAreUniqueValidator\" composedCheck = \"org.eclipse.xtext.validation.ImportUriValidator\" } ... Modify your grammar to include an import statement with a special \"importURI\"-field. Model : imports += Import * packages += Pack * ; Import : \"import\" importURI = STRING ... add the following to your *RuntimeModule (located side-by-side to your grammar) override bindIGlobalScopeProvider () { ImportUriGlobalScopeProvider } With this addition, the example above needs to be changed in file p2.mydsl: import \"p1.mydsl\" package p2 { call p1 . a1 } Customize lookup of local elements The following example illustrates a simple object oriented language, where you can define classes, create instances, and call methods of classes associated to that instances. package p1 { class C1 { def a1 def b1 } instance i1: C1 call i1->a1 call i1->b1 } When model references point to relative model element locations, you need a custom scope provider for that reference. The reference to \"a1\" in \"i1->a1\" cannot be resolved by the default scope provider, because the semantics of the call are not defined by the grammar. In the example shown, \"i1->a1\" points to \"a1\", which can be resolved by following the reference to the definition of \"i1\", and then following there the reference to \"C1\", which contains the desired definition of \"a1\". Model : imports += Import * packages += Pack * ; Pack : 'package' name = ID '{' ( class += Class | instances += Instance | calls += Call )* '}' ; Class : 'class' name = ID \"{\" defs += Def * \"}\" ; Def : 'def' name = ID ; Instance : 'instance' name = ID ':' type = [ Class|FQN ]; Call : 'call' instance = [ Instance|FQN ] '->' ref = [ Def ]; FQN hidden() : ID ( '.' ID )* ; Import : \"import\" importURI = STRING ; To resolve the reference of the \"call\", you need to specify a custom scope provider in \"scoping/MyDslScopeProvider.xtend\", side-by-side to your grammar: You get the \"object\" (in our case the \"call\"-object) and a \"reference\" identifying the part of grammar representing the reference to be resolved (in our case the attribute \"ref\" of the \"Call\"). Using \"object\" and \"reference\" you can decide where to handle scoping here, or delegating scoping to the default implementation \"return super.getScope(...)\". Based on the object you can implement your scoping logic defining what objects are visible (e.g. all \"Def\"-objects in \"call.instance.type.defs\"). Use Scopes.scopeFor(...) to return your selection. When you decide that no elements are visible, return \"IScope.NULLSCOPE\". class MyDslScopeProvider extends AbstractMyDslScopeProvider { override getScope ( EObject object , EReference ref ) { if ( ref == MyDslPackage . Literals . CALL__REF ) { val call = object as Call return Scopes . scopeFor ( call . instance . type . defs ) } return super . getScope ( object , ref ) } } Exercise \"modeling inheritance\" Here, you have to extend the language above to support inheritance. The following example should parse. package p1 { class C1 { def a1 } class C2 extends C1 { def b1 } instance i1: C1 instance i2: C2 call i1->a1 //call i1->b1 // error call i2->a1 call i2->b1 } The basic steps are as follows: Extend your grammar to support the optional \"extends\" syntax. Extend your scope provider to concatenate the list of \"Def\" elements of a class with the \"Def\" elements of a base class (recursively). Hint: java.util.Lists<T> can be concatenated using \"+\". This unittest can be used to check the correct functionality: /* * generated by Xtext 2.14.0 */ package org . xtext . example . mydsl . tests import com.google.inject.Inject import org.eclipse.xtext.testing.InjectWith import org.eclipse.xtext.testing.XtextRunner import org.eclipse.xtext.testing.util.ParseHelper import static extension org . junit . Assert .* import org.junit.Test import org.junit.runner.RunWith import org.xtext.example.mydsl.myDsl.Model import org.eclipse.xtext.testing.validation.ValidationTestHelper import org.xtext.example.mydsl.myDsl.MyDslPackage @RunWith ( XtextRunner ) @InjectWith ( MyDslInjectorProvider ) class MyDslParsingTest { @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper testHelper ; @Test def void loadModel () { val result = parseHelper . parse ( ''' package p1 { class C1 { def a1 } class C2 extends C1 { def b1 } instance i1: C1 instance i2: C2 call i1->a1 //call i1->b1 // error call i2->a1 call i2->b1 } ''' ) result . assertNotNull result . assertNoErrors // check call references: assertTrue ( result . packages . head . class_ . head . defs . head == result . packages . head . calls . get ( 0 ). ref ) assertTrue ( result . packages . head . class_ . head . defs . head == result . packages . head . calls . get ( 1 ). ref ) assertTrue ( result . packages . head . class_ . head . defs . head != result . packages . head . calls . get ( 2 ). ref ) assertTrue ( result . packages . head . class_ . last . defs . head == result . packages . head . calls . get ( 2 ). ref ) } @Test def void loadModelWithError () { val result = parseHelper . parse ( ''' package p1 { class C1 { def a1 } class C2 extends C1 { def b1 } instance i1: C1 instance i2: C2 call i1->a1 call i1->b1 // error call i2->a1 call i2->b1 } ''' ) result . assertNotNull result . assertError ( MyDslPackage . eINSTANCE . call , org . eclipse . xtext . diagnostics . Diagnostic . LINKING_DIAGNOSTIC ) } } Note: When you do not know the error code (\"LINKING_DIAGNOSTIC\") you can check the output of your unittest to get (and check) the information. For custom validators, the error code is the one passed to the error/warning function within your validation code.","title":"Scoping"},{"location":"xtext_scoping/#xtext-scoping","text":"In this section you will learn the following: What scoping means and where you need it. How to customize scoping for special lookups of local elements. How to select scope providers to handle models distributed across different files.","title":"Xtext Scoping"},{"location":"xtext_scoping/#scoping-what-is-it-and-where-do-i-need-it","text":"Scoping is always relevant, when a reference (e.g., \"Thing: ref=[OtherThing]\") is resolved after parsing the model text. Details see basics.md .","title":"Scoping: What is it and where do I need it?"},{"location":"xtext_scoping/#scoping-global-identification-of-elements","text":"When you identify an element by name (in order to reference it) you use the default scope provider of Xtext. It resembles the Java scope (based on packages separated by dots).","title":"Scoping: Global identification of elements"},{"location":"xtext_scoping/#problem","text":"In order to make use of the full qualified name of an element the default format of references is not enough to formulate the name (because dots are not part of this default format): Model : packages += Pack * ; Pack : 'package' name = ID '{' ( defs += Def | calls += Call )* '}' ; Def : 'def' name = ID ; Call : 'call' ref = [ Def ]; // same as \"ref=[Def|ID]\" With this grammar the default format \"ID\" is used to reference A objects in B objects. The following will work because all elements are in the same hierarchical element (Package): package p1 { def a1 def a2 call a1 call a2 } The following will not work package p1 { def a1 } package p2 { def a2 call a1 // will not work (a1 is located in p1) call a2 }","title":"Problem"},{"location":"xtext_scoping/#solution","text":"Model : packages += Pack * ; Pack : 'package' name = ID '{' ( defs += Def | calls += Call )* '}' ; Def : 'def' name = ID ; Call : 'call' ref = [ Def|FQN ]; FQN hidden() : ID ( '.' ID )* ; Here we allow the format of the reference to be a dot-separated name. Note : The optional \"hidden()\" controls which tokens are ignored (hidden). Hidden tokens are, e.g., whitespaces and comments by default. With \"hidden()\" no such tokens are ignored, thus, not allowing, e.g., whitespaces between the dot separated parts of a name.* With this, the default scope provider allows models as in the following example: package p1 { def a1 } package p2 { def a2 call p1.a1 call a2 }","title":"Solution"},{"location":"xtext_scoping/#models-distributed-across-multiple-files","text":"When distributing the model across different file, you can control how model elements are allowed to reference other model elements in different model files.","title":"Models distributed across multiple files"},{"location":"xtext_scoping/#defaultglobalscopeprovider-make-everything-visible","text":"The default scope provider allows referencing any model element in the available resources. In case of an eclipse project with model files, those resources consist of all model files in the current project. Thus, you can reference any model element without any import or include statement. For example, elements from p1.mydsl: package p1 { def a1 } may be referenced by elements in p2.mydsl: package p2 { call p1.a1 } Note: When creating a standalone compiler for your DSL, you do not have such things as a workspace. In this case, you can manually provide this information, as illustrated in xtext_deploy_command_line.md .","title":"DefaultGlobalScopeProvider \"make everything visible\""},{"location":"xtext_scoping/#importuriglobalscopeprovider-include-other","text":"You can easily change the visibility to provide a language with explicit import statements; see e.g. (Mooij et al, 2017b) . These steps sum up as follows for a simple default project: Add the \"ImportUriValidator\" in your mwe2-file (side-by-side to your grammar). ... validator = { // composedCheck = \"org.eclipse.xtext.validation.NamesAreUniqueValidator\" composedCheck = \"org.eclipse.xtext.validation.ImportUriValidator\" } ... Modify your grammar to include an import statement with a special \"importURI\"-field. Model : imports += Import * packages += Pack * ; Import : \"import\" importURI = STRING ... add the following to your *RuntimeModule (located side-by-side to your grammar) override bindIGlobalScopeProvider () { ImportUriGlobalScopeProvider } With this addition, the example above needs to be changed in file p2.mydsl: import \"p1.mydsl\" package p2 { call p1 . a1 }","title":"ImportUriGlobalScopeProvider \"#include &lt;other&gt;\""},{"location":"xtext_scoping/#customize-lookup-of-local-elements","text":"The following example illustrates a simple object oriented language, where you can define classes, create instances, and call methods of classes associated to that instances. package p1 { class C1 { def a1 def b1 } instance i1: C1 call i1->a1 call i1->b1 } When model references point to relative model element locations, you need a custom scope provider for that reference. The reference to \"a1\" in \"i1->a1\" cannot be resolved by the default scope provider, because the semantics of the call are not defined by the grammar. In the example shown, \"i1->a1\" points to \"a1\", which can be resolved by following the reference to the definition of \"i1\", and then following there the reference to \"C1\", which contains the desired definition of \"a1\". Model : imports += Import * packages += Pack * ; Pack : 'package' name = ID '{' ( class += Class | instances += Instance | calls += Call )* '}' ; Class : 'class' name = ID \"{\" defs += Def * \"}\" ; Def : 'def' name = ID ; Instance : 'instance' name = ID ':' type = [ Class|FQN ]; Call : 'call' instance = [ Instance|FQN ] '->' ref = [ Def ]; FQN hidden() : ID ( '.' ID )* ; Import : \"import\" importURI = STRING ; To resolve the reference of the \"call\", you need to specify a custom scope provider in \"scoping/MyDslScopeProvider.xtend\", side-by-side to your grammar: You get the \"object\" (in our case the \"call\"-object) and a \"reference\" identifying the part of grammar representing the reference to be resolved (in our case the attribute \"ref\" of the \"Call\"). Using \"object\" and \"reference\" you can decide where to handle scoping here, or delegating scoping to the default implementation \"return super.getScope(...)\". Based on the object you can implement your scoping logic defining what objects are visible (e.g. all \"Def\"-objects in \"call.instance.type.defs\"). Use Scopes.scopeFor(...) to return your selection. When you decide that no elements are visible, return \"IScope.NULLSCOPE\". class MyDslScopeProvider extends AbstractMyDslScopeProvider { override getScope ( EObject object , EReference ref ) { if ( ref == MyDslPackage . Literals . CALL__REF ) { val call = object as Call return Scopes . scopeFor ( call . instance . type . defs ) } return super . getScope ( object , ref ) } }","title":"Customize lookup of local elements"},{"location":"xtext_scoping/#exercise-modeling-inheritance","text":"Here, you have to extend the language above to support inheritance. The following example should parse. package p1 { class C1 { def a1 } class C2 extends C1 { def b1 } instance i1: C1 instance i2: C2 call i1->a1 //call i1->b1 // error call i2->a1 call i2->b1 } The basic steps are as follows: Extend your grammar to support the optional \"extends\" syntax. Extend your scope provider to concatenate the list of \"Def\" elements of a class with the \"Def\" elements of a base class (recursively). Hint: java.util.Lists<T> can be concatenated using \"+\". This unittest can be used to check the correct functionality: /* * generated by Xtext 2.14.0 */ package org . xtext . example . mydsl . tests import com.google.inject.Inject import org.eclipse.xtext.testing.InjectWith import org.eclipse.xtext.testing.XtextRunner import org.eclipse.xtext.testing.util.ParseHelper import static extension org . junit . Assert .* import org.junit.Test import org.junit.runner.RunWith import org.xtext.example.mydsl.myDsl.Model import org.eclipse.xtext.testing.validation.ValidationTestHelper import org.xtext.example.mydsl.myDsl.MyDslPackage @RunWith ( XtextRunner ) @InjectWith ( MyDslInjectorProvider ) class MyDslParsingTest { @Inject extension ParseHelper < Model > parseHelper @Inject extension ValidationTestHelper testHelper ; @Test def void loadModel () { val result = parseHelper . parse ( ''' package p1 { class C1 { def a1 } class C2 extends C1 { def b1 } instance i1: C1 instance i2: C2 call i1->a1 //call i1->b1 // error call i2->a1 call i2->b1 } ''' ) result . assertNotNull result . assertNoErrors // check call references: assertTrue ( result . packages . head . class_ . head . defs . head == result . packages . head . calls . get ( 0 ). ref ) assertTrue ( result . packages . head . class_ . head . defs . head == result . packages . head . calls . get ( 1 ). ref ) assertTrue ( result . packages . head . class_ . head . defs . head != result . packages . head . calls . get ( 2 ). ref ) assertTrue ( result . packages . head . class_ . last . defs . head == result . packages . head . calls . get ( 2 ). ref ) } @Test def void loadModelWithError () { val result = parseHelper . parse ( ''' package p1 { class C1 { def a1 } class C2 extends C1 { def b1 } instance i1: C1 instance i2: C2 call i1->a1 call i1->b1 // error call i2->a1 call i2->b1 } ''' ) result . assertNotNull result . assertError ( MyDslPackage . eINSTANCE . call , org . eclipse . xtext . diagnostics . Diagnostic . LINKING_DIAGNOSTIC ) } } Note: When you do not know the error code (\"LINKING_DIAGNOSTIC\") you can check the output of your unittest to get (and check) the information. For custom validators, the error code is the one passed to the error/warning function within your validation code.","title":"Exercise \"modeling inheritance\""},{"location":"xtext_xtend/","text":"Xtend: Selected Aspects In addition to the features sketched in the \"code generation with Xtend\" section this section provides some selected aspects we found useful for our work. Get more help: (Xtend Help) . Extension mechanism Xtend has its name from the the fact that it allows to extend classes of the language without using inheritance. There are different possibilities to achieve this task. One simple example of such an extended class is java.lang.String, which was extended by Xtend to provide a method \"toFirstUpper\". A simple possibility to achieve such an extension is to define a locally visible method \" f(__TypeX x, ...) \" (see Xtend documentation ). With this, TypeX is extended by a method __f(...) . def printNTimes ( String s , int n ) { for ( var i = 0 ; i < n ; i ++) println ( s ) } ... \"Hello\" . printNTimes ( 3 ) ... Other possibilities (see Xtend documentation ) allow to use static methods in a similar way (\"extension imports\") which can be imported by other modules: \"import static extension package.Type.printNTimes\". Dispatch methods A method (used as extension of not) can be marked with the keyword \" dispatch \". If such a method is defined multiple times with different specialized types as argument, the correct version of the method if called depending what object is passed (runtime polymorphism). The code behaves if an \"if obj instanceof TYPE\" is called to determine which version has to be called. Misc \u201e==\u201c vs. \u201e===\u201c (analogous \u201e!=\u201c vs. \u201e!==\u201c): \u201e==\u201c uses the method \"equals\" to determine the result. \u201e===\u201c checks if the identical object is referenced (like a pointer comparison). It is possible to check if an optional model element is present or not by comparing it to null. It is possible to check if a model element is not yet loaded (eIsProxy==true). EMF Parent Relationship (model navigation) Sometimes (while generating code or validating the model) it is useful to navigate to the parent of a model object. This can be done with the attribute \"eContainer\" of every model element. It may be necessary to cast this parent to an appropriate type (this can also happen via a dispatch method). List element access Lists can be accessed, e.g., via \"head\" (the first element) or \"get(index)\" (the i.th element). Filter and map functions, lambdas and passing lambdas Filter functions can be used to filter a list (like the unix command grep). Map functions can be used to transform a list of elements (like the unix command sed): resource . allContents . filter ( Entity ) . map [ name ] . join ( ', ' )) Details: \"filter(TYPE)\" filters the list to yield all entries of type \"TYPE\". \"filter(LAMBDA)\" filters the list using the \"LAMBDA\" as selector (if the LAMBDA returns true, the element is returned). \"map(LAMBDA)\" transforms each element using the \"LAMBDA\". Functions expecting a lambda can be called omitting the brackets \"(...)\". Lambda have the following syntax \"[a | a.name]\" is the same as \"[name]\" or \"[it.name]\" (\"it\" is the default parameter name). \"return\" can be omitted: the last command yields the return value.","title":"Xtend: Selected Aspects"},{"location":"xtext_xtend/#xtend-selected-aspects","text":"In addition to the features sketched in the \"code generation with Xtend\" section this section provides some selected aspects we found useful for our work. Get more help: (Xtend Help) .","title":"Xtend: Selected Aspects"},{"location":"xtext_xtend/#extension-mechanism","text":"Xtend has its name from the the fact that it allows to extend classes of the language without using inheritance. There are different possibilities to achieve this task. One simple example of such an extended class is java.lang.String, which was extended by Xtend to provide a method \"toFirstUpper\". A simple possibility to achieve such an extension is to define a locally visible method \" f(__TypeX x, ...) \" (see Xtend documentation ). With this, TypeX is extended by a method __f(...) . def printNTimes ( String s , int n ) { for ( var i = 0 ; i < n ; i ++) println ( s ) } ... \"Hello\" . printNTimes ( 3 ) ... Other possibilities (see Xtend documentation ) allow to use static methods in a similar way (\"extension imports\") which can be imported by other modules: \"import static extension package.Type.printNTimes\".","title":"Extension mechanism"},{"location":"xtext_xtend/#dispatch-methods","text":"A method (used as extension of not) can be marked with the keyword \" dispatch \". If such a method is defined multiple times with different specialized types as argument, the correct version of the method if called depending what object is passed (runtime polymorphism). The code behaves if an \"if obj instanceof TYPE\" is called to determine which version has to be called.","title":"Dispatch methods"},{"location":"xtext_xtend/#misc","text":"\u201e==\u201c vs. \u201e===\u201c (analogous \u201e!=\u201c vs. \u201e!==\u201c): \u201e==\u201c uses the method \"equals\" to determine the result. \u201e===\u201c checks if the identical object is referenced (like a pointer comparison). It is possible to check if an optional model element is present or not by comparing it to null. It is possible to check if a model element is not yet loaded (eIsProxy==true).","title":"Misc"},{"location":"xtext_xtend/#emf-parent-relationship-model-navigation","text":"Sometimes (while generating code or validating the model) it is useful to navigate to the parent of a model object. This can be done with the attribute \"eContainer\" of every model element. It may be necessary to cast this parent to an appropriate type (this can also happen via a dispatch method).","title":"EMF Parent Relationship (model navigation)"},{"location":"xtext_xtend/#list-element-access","text":"Lists can be accessed, e.g., via \"head\" (the first element) or \"get(index)\" (the i.th element).","title":"List element access"},{"location":"xtext_xtend/#filter-and-map-functions-lambdas-and-passing-lambdas","text":"Filter functions can be used to filter a list (like the unix command grep). Map functions can be used to transform a list of elements (like the unix command sed): resource . allContents . filter ( Entity ) . map [ name ] . join ( ', ' )) Details: \"filter(TYPE)\" filters the list to yield all entries of type \"TYPE\". \"filter(LAMBDA)\" filters the list using the \"LAMBDA\" as selector (if the LAMBDA returns true, the element is returned). \"map(LAMBDA)\" transforms each element using the \"LAMBDA\". Functions expecting a lambda can be called omitting the brackets \"(...)\". Lambda have the following syntax \"[a | a.name]\" is the same as \"[name]\" or \"[it.name]\" (\"it\" is the default parameter name). \"return\" can be omitted: the last command yields the return value.","title":"Filter and map functions, lambdas and passing lambdas"}]}